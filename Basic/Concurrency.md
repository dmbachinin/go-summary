# Concurrency

В Go конкурентность строится вокруг горутин (лёгких потоков исполнения, управляемых рантаймом) и каналов (типобезопасных очередей для синхронизации и обмена данными). Модель следует принципу CSP (Communicating Sequential Processes): вместо «делиться памятью между потоками» — «общайтесь через каналы». Это упрощает код, снижает количество блокировок и ошибок синхронизации по сравнению с традиционной моделью потоков.

- [Concurrency](#concurrency)
  - [Горутины](#горутины)
  - [Каналы](#каналы)
  - [select](#select)
    - [reflect.Select](#reflectselect)
  - [Механизмы синхронизации горутин](#механизмы-синхронизации-горутин)
    - [sync.WaitGroup](#syncwaitgroup)
    - [sync.Mutex и sync.RWMutex](#syncmutex-и-syncrwmutex)
    - [sync.Cond](#synccond)
    - [sync.Once](#synconce)
    - [sync/atomic](#syncatomic)
    - [sync.Map](#syncmap)
    - [os/signal](#ossignal)
  - [Планировщик](#планировщик)
    - [Настройка планировщика Go](#настройка-планировщика-go)
  - [Переключение горутин (context switch)](#переключение-горутин-context-switch)
  - [Использование горутин](#использование-горутин)

## Горутины

`Горутина` — это единица конкурентного исполнения в Go, управляемая рантаймом и планировщиком M:N. С точки зрения ОС горутина не является отдельным системным потоком: тысячи горутин мультиплексируются поверх небольшого пула потоков ОС. У горутины есть собственный стек (растущий/сжимаемый) и минимальные метаданные, а переключение между горутинами выполняет сам рантайм Go.

**Начальный размер стека горутины — около 2 KB** на большинстве 64‑битных платформ; стек динамически растёт (через копирование на более крупный сегмент) и может сжиматься при бездействии.

```go
    go fmt.Println("hello from goroutine") // В Go любой метод можно запустить асинхронно при помощи go
```

## Каналы

`Канал (channel)` — это объект в Go для безопасного обмена данными между горутинами.
Он реализует концепцию очереди FIFO и синхронизацию одновременно: передача данных через канал автоматически синхронизирует отправителя и получателя.

**Особенности:**

- `Типизированный`: канал всегда передаёт значения одного типа (chan int, chan string, chan MyStruct).
- `Nil-канал`: **var ch chan int по умолчанию nil**. Операции чтения/записи в такой канал блокируют горутину навсегда
- `Направленность`: канал может быть двунаправленным (chan T) или ограниченным по направлению

- `Небуферизированный канал`:
  - send и receive — это rendezvous: обе стороны должны встретиться.
  - Отправитель не «кладёт» значение внутрь канала заранее. Значение копируется напрямую получателю в момент встречи.
  - До встречи отправитель/получатель паркуются (блокируются на уровне горутин).

- `Буферизированный канал`:
  - Канал содержит очередь ёмкостью N.
  - send:
    - если len(ch) < cap(ch) — значение кладётся в очередь, отправитель не блокируется;
    - если len(ch) == cap(ch) — отправитель блокируется, пока читатель не освободит место.
  - receive:
    - если len(ch) > 0 — значение извлекается из очереди, получатель не блокируется;
    - если len(ch) == 0 — получатель блокируется, пока отправитель не положит значение.

```go
    ch := make(chan int) // небуферизированный канал int. Отправитель ждёт, пока получатель прочтёт, и наоборот. Это строгая синхронизация
    go func() {
        ch <- 100 // горутина заблокируется, пока не будет прочитано значение
    }()
    val := <-ch

    ch := make(chan string, 2) // буферизированный канал string ёмкостью 2. В канале есть очередь из N элементов. Отправитель блокируется, только если буфер заполнен. Получатель блокируется, если буфер пуст.
    go func() {
        ch <- "hello"
        ch <- "world"
        ch <- "!" // здесь будет блокировка — буфер заполнен
    }()
    val := <-ch

    ch <- 42 // Отправляем 42 в канал (может блокировать)
    val := <-ch // Читаем из канала (может блокировать)
    close(ch) // Запрещает новые записи, но чтение оставшихся элементов возможно
    ch <- 42 // Если положить значение в закрытый канал, то будет паника
    val, ok := <-ch // ok=false, если канал закрыт и пуст. Если канал закрыт и пуст → возвращает нулевое значение типа без информации

    if v, ok := <-ch; ok { // Проверка состояния при чтении
        fmt.Println("получено:", v)
    } else {
        fmt.Println("канал закрыт")
    }

    for v := range ch {
        fmt.Println(v) // Читает до закрытия канала
    }

    func producer(out chan<- int) { out <- 1 } // Только запись
    func consumer(in <-chan int) { fmt.Println(<-in) } // Только чтение
```

## select

`select` — специальный оператор языка Go для мультиплексирования операций на каналах. Он одновременно «ждёт» несколько операций (send/receive) и выполняет любую, которая первая становится готовой.

`ДОКУМЕНТАЦИЯ:`<https://go.dev/ref/spec#Select_statements>

1. Если готово несколько — одна выбирается случайным образом (без строгой справедливости).
2. Если не готова ни одна и есть ветка default — выполняется default немедленно, иначе текущая горутина блокируется до готовности хотя бы одной ветки

**Особенности:**

- `Готовность веток`
  - Ветка case x := <-ch готова, когда в ch есть значение (включая «готовность» закрытого канала тогда вернётся нулевое значение и ok=false).
  - Ветка case ch <- v готова, когда в ch есть место (для небуферизированного — когда есть получатель).
- `Выбор ветки`. Если готово несколько веток — выбирается случайно. На строгую «справедливость» и порядок не полагайтесь.
- `Блокировка`. Если нет готовых веток и нет default — горутина паркуется до события. Блокируется горутина, а не поток ОС.
- `default`. Делает select неблокирующим. Полезно для «probe/try» операций, но легко устроить busy-wait.

**Чтение из закрытого и пустого канала в Go всегда немедленно готово и возвращает нулевое значение** типа и ok=false (во «второй» форме чтения). Если использовать однозначную форму (v := <-ch) внутри select, то ветка будет готова всегда после опустошения буфера — и вы получите бесконечный поток нулевых значений (и, по сути, busy loop).

```go
    func breakOuterLoop(stop <-chan struct{}, in <-chan int) {
    outer:
        for {
            select {
            case <-stop:
                break outer
            case v, ok := <-in:
                if !ok { break outer } // Канал закрыт и пуст — корректно выходим. В select правильная практика после обнаружения закрытия — отключить ветку: присвоить каналу nil или выйти из цикла.
                fmt.Println(v)
            }
        }
    }

    select {
    case v := <-ch: // ОПАСНО: после закрытия будет готово всегда и v==0
        return v, nil // можете «съесть» ложный 0
    }

    for in1 != nil || in2 != nil {
        select {
        case v, ok := <-in1:
            if !ok { in1 = nil; continue } // отключаем ветку
            out <- v
        case v, ok := <-in2:
            if !ok { in2 = nil; continue } // отключаем ветку
            out <- v
        }
    }

    // Несколько выходных каналов, отправляем данные в первый готовый
    select {
    case ch1 <- 10:
        fmt.Println("отправили 10 в ch1")
    case ch2 <- 20:
        fmt.Println("отправили 20 в ch2")
    default:
        fmt.Println("оба канала заняты — ничего не отправили")
    }
```

### reflect.Select

`reflect.Select` — это динамический аналог оператора select, позволяющий строить выборку каналов не статически в коде, а во время выполнения.
В отличие от обычного select, где все ветки известны на этапе компиляции, reflect.Select принимает срез структур reflect.SelectCase, которые можно формировать динамически

**Особенность:**

- Семантика выбора такая же, как у обычного select:
  - если несколько веток готовы — выбор случайный,
  - если ни одна не готова и нет default — текущая горутина блокируется.
- Стоимость: reflect.Select медленнее обычного select (добавляется работа через reflect.Value и динамическое сопоставление). Используется только там, где статический select невозможен.

```go
    // Ветки задаются структурами reflect.SelectCase
    type SelectCase struct {
        Dir  SelectDir     // направление: recv, send, default
        Chan reflect.Value // канал (обёрнутый в reflect.Value)
        Send reflect.Value // значение для отправки (только для send)
    }
    // Направления (SelectDir):
    // reflect.SelectSend — операция записи в канал,
    // reflect.SelectRecv — операция чтения из канала,
    // reflect.SelectDefault — аналог ветки default

    chosen, recv, recvOK := reflect.Select(cases) // Результат работы
    // chosen — индекс выбранного case,
    // recv — значение, полученное при чтении (reflect.Value),
    // recvOK — false, если канал закрыт.


    func dynamicSelect(chs []<-chan int) {
        cases := make([]reflect.SelectCase, len(chs))
        for i, ch := range chs {
            cases[i] = reflect.SelectCase{
                Dir:  reflect.SelectRecv,  // читаем
                Chan: reflect.ValueOf(ch), // оборачиваем канал
            }
        }

        chosen, val, ok := reflect.Select(cases)
        if ok {
            fmt.Printf("канал[%d] дал значение %v\n", chosen, val.Int())
        } else {
            fmt.Printf("канал[%d] закрыт\n", chosen)
        }
    }

    func selectMixed(in <-chan int, out chan<- int) {
        cases := []reflect.SelectCase{
            {Dir: reflect.SelectRecv, Chan: reflect.ValueOf(in)}, // чтение
            {Dir: reflect.SelectSend, Chan: reflect.ValueOf(out), Send: reflect.ValueOf(42)}, // запись
            {Dir: reflect.SelectDefault}, // аналог default
        }

        chosen, val, ok := reflect.Select(cases)
        switch chosen {
        case 0:
            if ok {
                fmt.Println("прочитали:", val.Int())
            } else {
                fmt.Println("in закрыт")
            }
        case 1:
            fmt.Println("записали 42 в out")
        case 2:
            fmt.Println("default сработал")
        }
    }

```

## Механизмы синхронизации горутин

`Синхронизация горутин` — это управление их взаимодействием: передача данных, согласование доступа к памяти и упорядочивание событий. В Go синхронизация строится на двух уровнях:

- `Каналы (idiomatic way)` — синхронизация через передачу сообщений.
- `Пакет sync и sync/atomic` — низкоуровневые примитивы для защиты общей памяти

`ДОКУМЕНТАЦИЯ:` <https://pkg.go.dev/sync>

### sync.WaitGroup

`sync.WaitGroup` - Счётчик, показывающий, сколько горутин ещё работают

```go
    import "sync"

    var wg sync.WaitGroup

    for i := 0; i < 3; i++ {
        wg.Add(1) // Увеличиваем счетчик на 1
        go func(id int) {
            defer wg.Done() // Даем понять, что поток завершил работу (-1)
            // работа
        }(i)
    }

    wg.Wait() // Приостанавливает текущий поток пока счетчик не станет = 0

    wg.Go(f) // В Go 1.23+ есть удобный метод WaitGroup.Go(f), который сам делает Add(1), запускает горутину и по завершении вызывает Done()
```

### sync.Mutex и sync.RWMutex

`sync.Mutex` - Взаимное исключение для критических секций.

`sync.RWMutex` - Разделяемая/эксклюзивная блокировка. Позволяет отдельно блокировать поток на чтение и запись

Разблокировка может быть выполнена другой горутиной (мьютекс не «привязан» к владельцу)

```go
    import "sync"

    // sync.Mutex

    type SafeCounter struct {
        mu sync.Mutex
        n  int
    }

    func (c *SafeCounter) Inc() {
        c.mu.Lock() // Блокировка мьютекса
        defer c.mu.Unlock() // По завершении операции отпускаем мьютекс
        c.n++
    }

    func (c *SafeCounter) TryInc() bool {
        if c.mu.TryLock() { // Неблокирующая попытка
            c.n++
            c.mu.Unlock()
            return true
        }
        return false
    }

    // sync.RWMutex

    type Cache[K comparable, V any] struct {
        mu sync.RWMutex
        m  map[K]V
    }

    func (c *Cache[K, V]) Get(k K) (V, bool) {
        c.mu.RLock() // Блокировка потока на чтение
        v, ok := c.m[k]
        c.mu.RUnlock()
        return v, ok
    }

    func (c *Cache[K, V]) Put(k K, v V) {
        c.mu.WLock() // Блокировка потока на запись
        if c.m == nil { c.m = make(map[K]V) }
        c.m[k] = v
        c.mu.Unlock()
    }
```

### sync.Cond

`sync.Cond` — это примитив синхронизации в Go, который реализует условные переменные (condition variables).

Он используется для организации ожидания события: одна или несколько горутин могут «уснуть» до тех пор, пока другая горутина не разбудит их с помощью сигнала.

**Особенности:**

- `Работает в паре с мьютексом`. Когда горутина вызывает Wait(), она атомарно отпускает мьютекс и блокируется. После пробуждения — снова захватывает мьютекс.

- `Ожидание всегда в цикле`.Так как Wait() может пробудиться даже без вызова Signal (ложное пробуждение), стандартный паттерн:

    ```go
        for !условие {
            cond.Wait()
        }
    ```

```go
    // Ограниченная очередь с блокирующими методами Push и Pop
    type BoundedQueue[T any] struct {
        mu       sync.Mutex   // защищает доступ к buf
        notEmpty *sync.Cond   // сигнализирует, что в очереди есть элементы
        notFull  *sync.Cond   // сигнализирует, что в очереди есть место
        buf      []T
        capacity int
    }

    // Конструктор очереди
    func NewBoundedQueue[T any](cap int) *BoundedQueue[T] {
        bq := &BoundedQueue[T]{capacity: cap}
        bq.notEmpty = sync.NewCond(&bq.mu)
        bq.notFull = sync.NewCond(&bq.mu)
        return bq
    }

    // Добавление элемента (ждёт, если очередь полна)
    func (q *BoundedQueue[T]) Push(x T) {
        q.mu.Lock()
        for len(q.buf) == q.capacity {
            q.notFull.Wait() // Ждём, пока освободится место
        }
        q.buf = append(q.buf, x)
        q.notEmpty.Signal() // Будим одну горутину, ожидающую элемент
        q.mu.Unlock()
    }

    // Извлечение элемента (ждёт, если очередь пуста)
    func (q *BoundedQueue[T]) Pop() T {
        q.mu.Lock()
        for len(q.buf) == 0 {
            q.notEmpty.Wait() // ждём, пока появится элемент
        }
        x := q.buf[0]
        q.buf = q.buf[1:]
        q.notFull.Signal() // Будим одну горутину, ожидающую место
        q.mu.Unlock()
        return x
    }

    q.notFull.Broadcast() // Будит всех ожидающих
```

### sync.Once

`sync.Once` - Гарантирует выполнение переданной функции ровно один раз, даже при конкурентных вызовах из нескольких горутин. Типичный кейс — ленивые одноразовые инициализации. Даже если 1000 горутин одновременно вызовут once.Do(f), — f выполнится только в одной из них. Остальные будут ждать завершения этого вызова и продолжат работу без повторного выполнения.

**Особенности:**

- `Горутины блокируются`. Все параллельные вызовы Do(f) будут ждать, пока «первый» вызов не завершится.
- `Гарантия happens-before`. Когда f() завершилась в одной горутине, все последующие вызовы Do(f) видят уже инициализированное состояние.
- `Если f() паникнула`. То считается, что вызов не завершился корректно, и следующие вызовы попробуют выполнить f() снова. Это важно при инициализации ресурсов.
- Если функция уже была успешно вызвана — повторные вызовы игнорируются, даже если они происходят значительно позже.

```go
    import "sync"

    var (
        once sync.Once
        conn *Client // некий тяжёлый ресурс
    )

    func ClientInstance() *Client {
        once.Do(func() {
            conn = newClient() // инициализируется ровно один раз
        })
        return conn
    }
```

### sync/atomic

`sync/atomic` — это пакет стандартной библиотеки Go, предоставляющий атомарные операции над переменными, то есть такие операции, которые выполняются неделимо и безопасно при доступе из нескольких горутин одновременно, без использования мьютексов.

**Особенности:**

- `Атомарность`: операции гарантированно выполняются полностью, без прерывания другим потоком.
- `Барьеры памяти`: атомарные операции задают порядок видимости изменений для других горутин («happens-before»).
- `Производительность`: обычно быстрее мьютексов, но сложнее в использовании. Ошибки проектирования (например, смешивание атомарного доступа и обычного чтения одного и того же поля) приводят к data race.
- `Гибкость`: можно строить неблокирующие алгоритмы, но чаще используют для простых случаев — инкремент, статус-флаг, счётчик.
- Atomic не блокирует поток как Mutex, а выполняет операцию напрямую в памяти → горутины не ждут друг друга, если это простая операция

**Если не использовать Atomic:**

```go
    counter++ // это не атомарная операция

    // Если две горутины выполнят это одновременно, получится конфликт
    // goroutine 1: load(counter=5)
    // goroutine 2: load(counter=5)
    // goroutine 1: add → 6, store(6)
    // goroutine 2: add → 6, store(6)
    // Ожидали 7, а получили 6
```

**Основные методы:**

```go
    import "sync/atomic"

    // -------- ЧИСЛОВЫЕ ТИПЫ --------

    var counter atomic.Int64 // Создание атомарного счетчика (int64)

    // Запись значения
    counter.Store(10) // counter = 10

    // Чтение значения
    val := counter.Load() // 10

    // Атомарное увеличение (инкремент)
    counter.Add(1) // counter = 11

    // Атомарное уменьшение
    counter.Add(-5) // counter = 6

    // Swap — атомарная замена с возвратом старого значения
    old := counter.Swap(100) // old=6, counter=100

    // CompareAndSwap — если текущее == old, то заменить на new
    ok := counter.CompareAndSwap(100, 200) // ok=true, counter=200
    ok = counter.CompareAndSwap(100, 300)  // ok=false, counter=200


    // -------- БУЛЕВЫЕ ФЛАГИ --------

    // Создание атомарного bool
    var running atomic.Bool

    // Установка значения
    running.Store(true)

    // Чтение
    flag := running.Load() // true

    // CompareAndSwap — меняем только если текущее значение совпадает
    changed := running.CompareAndSwap(true, false) // changed=true

    // -------- УКАЗАТЕЛИ --------

    type Data struct{ Value int }
    var ptr atomic.Pointer[Data]

    // Установка указателя
    ptr.Store(&Data{Value: 42})

    // Чтение указателя
    d := ptr.Load() // *Data{Value:42}

    // Swap — замена указателя
    oldPtr := ptr.Swap(&Data{Value: 100}) // oldPtr -> *Data{42}, ptr -> *Data{100}

    // CompareAndSwap — если совпадает, заменить
    ok = ptr.CompareAndSwap(d, &Data{Value: 500})

```

### sync.Map

`sync.Map` — потокобезопасная (concurrent-safe) реализация ассоциативного массива (карты) в Go.
В отличие от обычной map[K]V, она изначально предназначена для конкурентного доступа из множества горутин без необходимости вручную защищать её sync.Mutex или sync.RWMutex.

**Особенности:**

- `Без блокировок при чтении`: для чтений используется оптимизированная стратегия («read-only» копия), что делает частые чтения быстрыми.
- `Безопасна для конкурентного доступа`: можно читать и писать в несколько горутин одновременно.
- `Оптимизация для сценариев «много чтений — мало записей»`: в случаях, где большинство операций чтения, sync.Map работает эффективнее, чем map с RWMutex.

```go
    import "sync"

    var m sync.Map

    // Store — сохранить значение по ключу
    m.Store("foo", 42)

    // Load — получить значение по ключу
    val, ok := m.Load("foo") // val=42, ok=true

    // LoadOrStore — если ключ есть, вернуть существующее значение,
    // если нет — записать новое и вернуть его
    actual, loaded := m.LoadOrStore("bar", 100)
    // loaded = false, если только что добавили
    // loaded = true, если ключ уже был

    // Swap — заменить значение и вернуть старое
    old, loaded := m.Swap("foo", 99) // old=42, loaded=true

    // CompareAndSwap — если текущее значение совпадает, заменить новым
    swapped := m.CompareAndSwap("foo", 99, 123) // true, foo=123

    // Delete — удалить элемент по ключу
    m.Delete("bar")

    // Range — итерация по всем ключам и значениям
    m.Range(func(key, value any) bool {
        fmt.Println("key:", key, "value:", value)
        return true // продолжать обход
    })
```

### os/signal

`Сигналы` — это механизм операционной системы для уведомления процесса о событиях (например, завершение, прерывание с клавиатуры, необходимость перезапуска). В Go для работы с ними используется пакет os/signal, который позволяет перехватывать и обрабатывать сигналы, а не завершать процесс сразу.

```go
    // Создаем канал для сигналов
    sigs := make(chan os.Signal, 1) // Обязательно должен быть буферезированным

    // Подписываемся на SIGINT (Ctrl+C) и SIGTERM (kill)
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

    fmt.Println("Ожидание сигналов...")

    // Ждем первый сигнал
    sig := <-sigs
    fmt.Println("Получен сигнал:", sig)

    signal.Stop(sigs) // Закрываем канал
```

**Список сигналов:**

```go
    // Сигналы завершения и управления процессом
    syscall.SIGINT    // Прерывание процесса (Ctrl+C в терминале)
    syscall.SIGTERM   // Завершение процесса (kill PID)
    syscall.SIGKILL   // Безусловное завершение (kill -9 PID), перехватить нельзя
    syscall.SIGSTOP   // Полная остановка процесса (kill -STOP PID), перехватить нельзя
    syscall.SIGCONT   // Возобновление процесса после SIGSTOP (kill -CONT PID)

    // Управление сессией и терминалом
    syscall.SIGHUP    // Закрытие терминала или разрыв сессии (kill -HUP PID)
    syscall.SIGQUIT   // Прерывание с дампом памяти (Ctrl+\ в терминале)
    syscall.SIGTTIN   // Фоновый процесс пытается читать с терминала
    syscall.SIGTTOU   // Фоновый процесс пытается писать в терминал
    syscall.SIGTSTP   // Остановка процесса (Ctrl+Z в терминале)

    // Ошибки исполнения
    syscall.SIGSEGV   // Ошибка сегментации (segmentation fault)
    syscall.SIGILL    // Недопустимая инструкция CPU
    syscall.SIGFPE    // Ошибка арифметики с плавающей точкой (деление на 0 и др.)
    syscall.SIGBUS    // Ошибка доступа к памяти (bus error)
    syscall.SIGTRAP   // Ловушка для отладчика (trap)
    syscall.SIGSYS    // Недопустимый системный вызов

    // Пользовательские сигналы
    syscall.SIGUSR1   // Пользовательский сигнал #1 (kill -USR1 PID)
    syscall.SIGUSR2   // Пользовательский сигнал #2 (kill -USR2 PID)

    // Сигналы от ядра / ошибок ввода-вывода
    syscall.SIGPIPE   // Запись в закрытый канал/сокет
    syscall.SIGCHLD   // Потомок завершился или изменил состояние
    syscall.SIGALRM   // Таймер истёк (setitimer/alarm)
    syscall.SIGPROF   // Профилирование (setitimer с профилировкой)
    syscall.SIGVTALRM // Виртуальный таймер истёк (виртуальное время процесса)
    syscall.SIGIO     // Асинхронное событие ввода-вывода
    syscall.SIGURG    // Срочные данные на сокете
    syscall.SIGXCPU   // Превышение лимита CPU
    syscall.SIGXFSZ   // Превышение лимита размера файла
```

## Планировщик

`Планировщик (scheduler)` в Go — это встроенный в рантайм компонент, который управляет выполнением goroutine. Он отвечает за то, какие горутины и когда будут выполняться на доступных потоках операционной системы. По сути, это "микро-операционная система" внутри Go-программы.

`СТАТЬЯ:` <https://habr.com/ru/articles/478168/>

В Go используется `M:N-планировщик`, где `M` — это machine thread (поток ОС), `N` — это goroutines (горутины).

**Go-планировщик использует три сущности:**

- G (goroutine) - сама горутина: стек, счётчик инструкций, ссылка на функцию, локальные данные, состояние (_Grunnable,_Grunning, _Gwaiting,_Gsyscall и др.)
- M (machine / thread) - поток ОС, на котором исполняется Go-код. M исполняет горутины, но для этого ему нужен P.
- P (processor):
  - логическая единица планирования внутри рантайма Go.
  - хранит локальную очередь горутин, кеши памяти и ресурсы рантайма.
  - Количество P = `GOMAXPROCS` (Сколько ядер Go может использовать). По умолчанию = количество логических процессоров доступных программе (CPU-ядер). Это ограничивает степень параллелизма, то есть сколько горутин реально может выполняться одновременно.

**Связь:**

- **M не может выполнять G напрямую — ему нужен P**. M лишь предоставляет поток ОС для исполнения; он не принимает решения сам. Все решения по планированию принимает рантайм Go через структуру P
- **G исполняется на M через P**.
- **P гарантирует, что горутины будут сбалансированы по ядрам**. Каждому P в момент времени прикреплён один M. P решает, какую горутину взять из своей локальной очереди. **Если очередь пустая**, P: **крадёт горутины из другой P** (work stealing), или **берёт горутины из глобальной очереди**.

**Пример схемы:**

```plantext

             ┌───────────┐
             │   G1      │ goroutine
             ├───────────┤
             │   G2      │
             ├───────────┤
             │   ...     │
             └───────────┘

   ┌───┐        ┌───┐        ┌───┐
   │ P │        │ P │  ...   │ P │   (processors, = GOMAXPROCS)
   └─┬─┘        └─┬─┘        └─┬─┘
     │            │            │
 ┌───▼───┐    ┌───▼───┐    ┌───▼───┐
 │   M   │    │   M   │    │   M   │  (OS threads)
 └───────┘    └───────┘    └───────┘

Горутины (G) ждут исполнения в очередях у P.
Потоки ОС (M) «подбирают» P и запускают горутины.
Количество активных P ограничивает реальный параллелизм.
```

### Настройка планировщика Go

Планировщик Go в основном управляется через пакет runtime и переменные окружения. Ниже приведён список всех основных команд и функций, которыми можно его настраивать.

**Переменные окружения:**

- `GOMAXPROCS` - Задаёт количество логических процессоров (P) — сколько горутин может выполняться одновременно (По умолчанию равно числу логических ядер CPU)

    ```sh
    GOMAXPROCS=4 go run main.go
    ```

- `GODEBUG` - Включает отладочные опции рантайма, в том числе планировщик
  - schedtrace=1000 — каждые 1000 мс выводит статистику планировщика (количество goroutine, загрузку P и т.д.).
  - scheddetail=1 — более подробная статистика (например, work stealing)

    ```sh
    GODEBUG=schedtrace=1000,scheddetail=1 go run main.go
    ```

**Функции пакета runtime:**

Под «C‑функциями» понимаются вызовы в код на C/C++ через cgo (любой внешний C‑API: системные библиотеки, OpenSSL, SQLite, GUI‑стеки и т.п.).s

```go
    import "runtime"
    prev := runtime.GOMAXPROCS(2) // Установить 2 P, вернуть старое значение
    runtime.Gosched() // Уступить выполнение другим горутинам
    runtime.Goexit() // Корректное завершение выполнение текущей горутины, при этом выполняются все defer
    // Возвращает количество доступных логических процессоров ОС
    cpus := runtime.NumCPU() // например, 8
    fmt.Println("Горутин:", runtime.NumGoroutine()) // Текущее количество активных горутин

    // Привязывает текущую горутину к конкретному системному потоку (нужно для работы с ОС/GUI/C‑функции)
    runtime.LockOSThread()
    // код, который должен выполняться строго в этом потоке
    runtime.UnlockOSThread()
```

## Переключение горутин (context switch)

- **выполняется рантаймом, а не ОС**; сохраняется PC/SP и часть регистров, меняется активный стек.
- триггеры для переключения: блокирующие операции (чтение/запись из канала, sync‑ожидание), системные вызовы (M уходит в `_Gsyscall`, P перепривязывается к другому M), time.Sleep, ожидание таймеров, кооперативная отмена по context, а также асинхронная предвыборка (preemption) рантаймом.
- начиная с Go 1.14 есть асинхронная предвыборка: рантайм прерывает «долго крутящиеся» горутины в безопасных точках (safe‑points), снижая «залипания» на CPU.

**Состояния горутин (внутренние):**

- `_Grunnable` (готова к запуску)
- `_Grunning` (исполняется)
- `_Gwaiting` (ждёт события/канала/мьютекса)
- `_Gsyscall` (в системном вызове)

## Использование горутин
