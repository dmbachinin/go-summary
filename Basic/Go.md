# Go

- [Go](#go)
  - [Определение языка](#определение-языка)
  - [Особенности работы go](#особенности-работы-go)
  - [Go Toolchain](#go-toolchain)
  - [Package](#package)
    - [Правила наименования пакетов](#правила-наименования-пакетов)
    - [Правила наименования файлов](#правила-наименования-файлов)
    - [Где Go ищет пакеты?](#где-go-ищет-пакеты)
    - [Пакет internal в Go](#пакет-internal-в-go)
  - [import](#import)
  - [main - запуск проекта](#main---запуск-проекта)
  - [go.mod](#gomod)
    - [Как работает go.mod?](#как-работает-gomod)
  - [go.sum](#gosum)
    - [Как go.sum работает?](#как-gosum-работает)
    - [Пример go.sum и его расшифровка](#пример-gosum-и-его-расшифровка)
    - [Версионирование в Go](#версионирование-в-go)
  - [Сборщик мусора](#сборщик-мусора)
  - [Выравнивание памяти в Go](#выравнивание-памяти-в-go)

## Определение языка

Go является кроссплатформенным, он позволяет создавать программы под различные операционные системы - Windows, Mac OS, Linux, FreeBSD. Код обладает переносимостью: программы, написанные для одной из этих операционных систем, могут быть легко с перекомпиляцией перенесены на другую ОС.

Основные особенности языка Go:

- компилируемый - компилятор транслирует программу на Go в машинный код, понятный для определенной платформы
- статически типизированный
- присутствует сборщик мусора, который автоматически очищает память
- поддержка работы с сетевыми протоколами
- поддержка многопоточности и параллельного программирования

`Effective Go`: <https://go.dev/doc/effective_go>

## Особенности работы go

**Go запрещает неиспользуемые переменные, так что каждая объявленная переменная должна быть использована в коде.**

## Go Toolchain

```sh
    go mod init project # Создать модуль с названием project
    go run main.go # Сборка и запуск проекта 
    go build main.go # Собрать проект в исполняемый файл
    go build # Собрать модуль в исполняемый файл

    # go.mod
    go get github.com/gin-gonic/gin # При добавлении нового пакета (go get) он записывается в go.mod
    go get -u github.com/gin-gonic/gin # Обновляет пакет до последней minor или patch версии
    go get -u=patch github.com/gin-gonic/gin # Обновляет только patch-версию (например, 1.8.0 → 1.8.2)
    go mod tidy # Удаление неиспользуемых пакетов
    go list -m all # Выводит список всех зависимостей
    go mod edit -go=1.21 # Обновляет версию Go в go.mod
    go mod verify # Проверить зависимость вручную. Проверяет все зависимости из `go.sum`

    go fmt ./... # Форматирует код под стандарты Go
    go test ./... # Запустить тесты во всех пакетах проекта
    go vet ./... # Проверить весь проект на потенциальные ошибки

    go install ./cmd/app # Компилирует и устанавливает бинарник в $GOPATH/bin или $HOME/go/bin
    # Например, ты написал утилиту для работы с API. После go install она будет доступна как команда в терминале
    go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest # Можно ставить сторонние инструменты прямо из интернета

    go env # Вывод переменных окружения Go Toolchain. Добавлять новые переменные окружения нельзя менять, они нужны только для данной утилиты
    go env GOPATH # Вывести одну переменную
    go env -w GOPATH=$HOME/dev/go # Изменение значения переменной
    go env -u GOBIN # Сброс значения

    go help <command> # Вывод справки по команде

```

**./...** - это шаблон путей (wildcard), который используется в командах Go для рекурсивного выбора всех пакетов начиная с текущей директории (./) и включая все вложенные

Особенности:

- ./ — означает текущую директорию.
- ... — специальный паттерн Go, который означает «все подпакеты рекурсивно».
- Работает в большинстве команд: go build, go test, go fmt, go vet, go doc и др.
- Удобно для применения операции сразу ко всему проект

## Package

В Go **packages (пакеты)** — это основа организации кода. Они позволяют структурировать код, делать его переиспользуемым и управлять зависимостями. В Go каждый файл принадлежит какому-то пакету.

**Каждый файл Go принадлежит пакету**. В начале каждого .go файла обязательно указывается директива package

В Go **файлы внутри одного пакета могут использовать друг друга без явного импорта**. Это позволяет разбивать код на несколько файлов, но при этом они остаются частью одного логического модуля

Основные принципы взаимодействия файлов в одном пакете:

1. Все файлы одного пакета должны начинаться с одного и того же имени пакета (package mypackage).
2. **Функции, переменные и структуры, объявленные с заглавной буквы, доступны в других файлах** того же пакета и в других пакетах.
3. **Элементы, объявленные с маленькой буквы, доступны только внутри этого пакета**

**Виды пакетов:**

1. main - точно входа в приложение
2. service/... - свой пакет
3. fmt - пакет из стандартной библиотеки
4. github.com/gabriel-vasile/mimetype - внешний пакет

### Правила наименования пакетов

В Go пакеты (package) — это основной способ организации кода. Правильное именование пакетов критически важно для читаемости, поддержки и единообразия проекта

`РЕКОМЕНДАЦИИ:` <https://go.dev/wiki/CodeReviewComments#package-names>

**Особенности:**

- **имена пишутся в нижнем регистре — без заглавных букв, подчеркиваний и тире**
- краткие и ёмкие — обычно одно слово
- уникальные в пределах проекта, но не обязательно в глобальном пространстве
- совпадают с именем директории, где лежат файлы пакета
- не повторяют имя импорта — пакет должен быть самодостаточным (например, import "net/http" → пакет называется http, а не nethttp)
- не нужны префиксы — имя пакета уже будет использоваться как префикс при вызове функций (json.Marshal, а не encodingjson.Marshal)
- допустимы "внутренние" пакеты (internal) — скрывают код от внешнего использования
вспомогательные тесты могут быть в _test пакетах (например, mypkg_test)

### Правила наименования файлов

**Файлы в Go** — это единицы исходного кода внутри пакета. Их имена должны быть понятными, единообразными и отражать содержимое, но при этом оставаться простыми.

`РЕКОМЕНДАЦИИ:` <https://go.dev/wiki/CodeReviewComments#package-names>

В Go имя файла не влияет на импорт. Импорт всегда привязан к имени пакета и пути до директории, а не к конкретному файлу, как в Java

**Все .go-файлы внутри одной директории** (с одинаковым package) компилируются вместе. Имя файла используется только для удобства разработчика (читаемость, навигация)

**Особенности:**

- **имена файлов всегда в нижнем регистре**
- слова разделяются подчёркиванием (_), если нужно (http_server.go, user_service.go)
- без пробелов, дефисов и заглавных букв
- отражают назначение файла, а не структуру (лучше json_encoder.go, чем file1.go)
- тестовые файлы оканчиваются на _test.go (это обязательное требование go test)
- системно-специфичные файлы могут иметь суффиксы по ОС или архитектуре, например:
    file_linux.go
    file_windows.go
    file_amd64.go
- Go сам подключает нужный файл при сборке под конкретную платформу

сборочные теги (//go:build) также часто используются вместе с именами файлов

### Где Go ищет пакеты?

Go ищет пакеты в нескольких местах:

- В стандартной библиотеке.
- В GOROOT — это путь к стандартным библиотекам Go.
- В GOPATH — каталог с пользовательскими пакетами.
- В go.mod (если используется Go Modules).

### Пакет internal в Go

`internal` — это специальная директория в Go-проекте, которая делает все свои подпакеты доступными только внутри текущего модуля (или родительского пакета).
Это способ ограничить область видимости кода на уровне пакета, а не только имён

`ДОКУМЕНТАЦИЯ:` <https://go.dev/doc/go1.4#internalpackages>

**Особенности:**

- **Доступность только внутри модуля**. Если у тебя есть пакет по пути: **project/internal/timeutil/**. То project/internal/timeutil можно импортировать только из project/..., но не из внешнего кода
- Это удобный способ явно сказать: «этот пакет — внутренний, он не часть публичного API».
В отличие от Java (private/protected), тут ограничение действует на уровень пакета
- Любая вложенность работает. Этот **project/service/internal/cache** будет доступен только для project/service/..., но не для соседних пакетов уровня выше.

**Пример структуры:**

```plantext
    project/
    ├── go.mod
    ├── service/
    │   ├── user.go
    │   └── internal/
    │       └── validator/
    │           └── validate.go
    └── internal/
        └── timeutil/
            └── parse.go
```

```go
    // project/service/user.go
    package service

    import (
        "project/service/internal/validator" // OK
        "project/internal/timeutil"          // OK
    )

    // project/internal/timeutil/parse.go
    package timeutil

    import "project/service/internal/validator" // ❌ Не может импортировать project/service/internal/validator, потому что это «внутренний» пакет конкретно для project/service
```

## import

В Go импорт (import) используется для подключения стандартных библиотек, сторонних пакетов и внутренних модулей проекта.

**Виды импорта в Go:**

```go
    import "fmt" // Обычный импорт

    import ( // Импорт нескольких пакетов
        "fmt"                // стандартная библиотека
        "github.com/gin-gonic/gin" // сторонний пакет
        "project/utils"      // локальный модуль
    )

    import m "math" // Импорт с псевдонимом (именованный импорт)


    import (
    "database/sql"
        _ "github.com/lib/pq" // Используется, когда пакет нужен только для его инициализации, но напрямую его функции использовать не нужно
        // Подключаем PostgreSQL-драйвер
    )
    // При таком импорте вызывается функция init() из github.com/lib/pq, но сам пакет в коде не используется

    import . "fmt" // Можно импортировать пакет так, чтобы его функции можно было вызывать без префикса пакета
```

**Как работает импорт в Go?**

В Go компилятор ищет пакеты в нескольких местах:

1. Стандартные пакеты (GOROOT)
    - Хранятся в системных каталогах Go ($GOROOT).
    - Примеры: fmt, math, strings.
2. Внешние пакеты (GOPATH/pkg/mod)
    - После установки через go get пакеты попадают в GOPATH/pkg/mod.
3. Локальные модули (go.mod)
    - В go.mod указывается, какие пакеты принадлежат проекту.
    - Файлы ищутся в каталогах проекта.

## main - запуск проекта

**main** — это точка входа в исполняемую программу на Go. В Go main не принимает параметры командно строки

⚠️ Если в проекте нет **func main** в пакете main, go build не создаст бинарник (получим библиотеку вместо исполняемого файла)

```go
    package main // Должна находиться в пакете main 

    import "fmt"

    func main() { // Сигнатура всегда одинаковая
        fmt.Println("Hello, Go!")
    }
```

## go.mod

Файл **go.mod** — это файл управления модулями в Go. Он управляет зависимостями, определяет версию Go и содержит информацию о пакете

`ДОКУМЕНТАЦИЯ`: <https://go.dev/ref/mod>

**Файл go.mod решает несколько задач:**

- Определяет модуль проекта (его имя и путь).
- Хранит список зависимостей (внешних пакетов с версиями).
- Обеспечивает воспроизводимость сборки (фиксируя версии).
- Позволяет управлять зависимостями (обновлять, удалять, фиксировать версии).

```sh
    go mod init myproject # Создать go.mod

    go get github.com/gin-gonic/gin # При добавлении нового пакета (go get) он записывается в go.mod
    go get github.com/user/project@v1.2.3 # Можно явно указать нужную версию
    
    go get github.com/google/uuid@v1 # Установка последней минорной версии в рамках major
    go get -u github.com/gin-gonic/gin # Обновляет пакет до последней minor или patch версии
    go get -u=patch github.com/gin-gonic/gin # Обновляет только patch-версию (например, 1.8.0 → 1.8.2)
    
    go mod tidy # Удаление неиспользуемых пакетов
    go list -m all # Выводит список всех зависимостей
    go mod edit -go=1.21 # Обновляет версию Go в go.mod
    go mod verify # Проверить зависимость вручную. Проверяет все зависимости из `go.sum`
```

### Как работает go.mod?

```plaintext
    module myproject // Определяет имя модуля (обычно это путь к репозиторию: github.com/username/repo)

    go 1.20 // Указывает минимальную версию Go

    // Все зависимости кэшируются в $GOPATH/pkg/mod (больше не нужна vendor)
    require (
        github.com/gin-gonic/gin v1.8.1
        github.com/google/uuid v1.3.0
    ) // Список зависимостей проекта и их версий

    replace (
        github.com/old/package v1.2.3 => github.com/new/package v1.4.0
    ) // Позволяет заменить одну зависимость на другую
    // Это полезно, если оригинальная библиотека устарела или была форкнута

    exclude github.com/bad/package v1.0.0 // Исключает определенные версии пакетов. Go не будет использовать v1.0.0 и выберет другую версию
```

**Пример:**

```go
    import (
        "fmt"
        "github.com/google/uuid" // Go не знает, какую версию github.com/google/uuid использовать. Если в go.mod нет этой зависимости, она добавится автоматически после go run main.go
    )
```

## go.sum

`go.sum` — это **файл контроля целостности зависимостей** в Go. Он автоматически создаётся при работе с Go Modules и хранит **хеши (контрольные суммы) всех зависимостей**.

**Основные задачи `go.sum`:**

- Проверяет, что загруженные зависимости **не были изменены** злоумышленниками.  
- Обеспечивает **воспроизводимость сборки** (один и тот же код всегда использует одни и те же зависимости).  
- Позволяет кешировать зависимости, не загружая их повторно.  

`go.sum` создаётся **автоматически**, как только проект использует `go mod init` или `go get`.

**`go.sum` нужно коммитить**, потому что:

- Он **гарантирует, что у всех разработчиков будут те же зависимости**.
- Без него `go mod tidy` может **получить другие версии пакетов**.

### Как go.sum работает?

Когда Go загружает зависимость (`go get`), он:

1. **Скачивает код пакета** и вычисляет его хеш.
2. **Сравнивает его с `go.sum`**, если он уже есть.
3. Если хеша **нет в `go.sum`**, Go записывает его туда.
4. Если хеш **не совпадает** с сохранённым, Go **выдаёт ошибку безопасности**.

### Пример go.sum и его расшифровка

```plaintext
github.com/google/uuid v1.3.0 h1:WxOfAxBx2...
github.com/google/uuid v1.3.0/go.mod h1:XxYzW...
```

**Разберём запись:**

- `github.com/google/uuid v1.3.0` — это **версия пакета**.
- `h1:` — означает, что используется **SHA-256** в формате `base64`.
- `WxOfAxBx2...` — это **контрольная сумма** содержимого пакета.
- `/go.mod` — означает, что это **хеш самого файла `go.mod`** в этом пакете.

### Версионирование в Go

В Go версии пакетов и модулей **привязаны к Git-тегам в удалённом репозитории**.
Go не хранит у себя несколько веток кода для разных версий — он получает их из VCS (GitHub, GitLab и т.д.) по конкретным тегам и кэширует в $GOPATH/pkg/mod.

`ДОКУМЕНТАЦИЯ:` <https://go.dev/doc/modules/version-numbers>

**Особенности:**

- SemVer — Go использует семантическое версионирование (vMAJOR.MINOR.PATCH):
  - MAJOR — ломающее изменение API (breaking change)
  - MINOR — новые возможности без ломающих изменений
  - PATCH — багфиксы
- Версия модуля = тег в Git. Например, v1.4.2 означает, что в репозитории есть тег v1.4.2.
- Если версия v2+, Go требует указать её в пути импорта: **module github.com/user/project/v2**. Это позволяет в одном проекте использовать одновременно v1 и v2 одной библиотеки
- При первой загрузке зависимости Go скачивает архив по конкретному тегу и кладёт его в модульный кэш ($GOPATH/pkg/mod), после чего всегда использует ту же версию

## Сборщик мусора

## Выравнивание памяти в Go
