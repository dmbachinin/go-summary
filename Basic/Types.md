# Types

`Статья на тему`: <https://metanit.com/go/tutorial/2.3.php>

Go является статически типизированным языком, что означает, что тип каждой переменной определяется во время компиляции и не может изменяться в процессе выполнения программы.

- [Types](#types)
  - [Целочисленные типы](#целочисленные-типы)
  - [Числа с плавающей точкой](#числа-с-плавающей-точкой)
  - [Комплексные числа](#комплексные-числа)
  - [Строки](#строки)
    - [Как Go считывает руны из строки?](#как-go-считывает-руны-из-строки)
    - [strings](#strings)
  - [Логический тип](#логический-тип)
  - [Преобразование типов](#преобразование-типов)
  - [Константы](#константы)
  - [Массивы](#массивы)
    - [Итерация по указателю на массив и самому массиву](#итерация-по-указателю-на-массив-и-самому-массиву)
    - [Стоимость копирования массивов и range в Go](#стоимость-копирования-массивов-и-range-в-go)
  - [Срезы](#срезы)
    - [Создание](#создание)
    - [Основные функции для работы со срезами](#основные-функции-для-работы-со-срезами)
      - [append](#append)
      - [Расширенные операции со срезами](#расширенные-операции-со-срезами)
        - [Сортировка среза (sort из sort пакета)](#сортировка-среза-sort-из-sort-пакета)
        - [Пакет slices (Go 1.21+)](#пакет-slices-go-121)
    - [Как работает выделение памяти для срезов?](#как-работает-выделение-памяти-для-срезов)
  - [Map](#map)
    - [Основные функции и операции](#основные-функции-и-операции)
      - [maps (Go 1.21+)](#maps-go-121)
    - [Таблица zero value для разных типов](#таблица-zero-value-для-разных-типов)
    - [Новая реализация map в (Go 1.24+)](#новая-реализация-map-в-go-124)
  - [Struct](#struct)
    - [Композиция (встраивание) Struct в Go](#композиция-встраивание-struct-в-go)
    - [Методы, привязанные к структурам](#методы-привязанные-к-структурам)
    - [struct tags](#struct-tags)
  - [Интерфейсы](#интерфейсы)
    - [Method set и Type set](#method-set-и-type-set)
  - [error](#error)
    - [Оборачивание](#оборачивание)
    - [Собственные ошибки](#собственные-ошибки)
    - [Работа с паникой (panic)](#работа-с-паникой-panic)

## Целочисленные типы

**Особенности:**
Выбор между знаковыми и беззнаковыми типами зависит от природы данных. Например, для счётчиков, которые не могут быть отрицательными, можно использовать беззнаковые типы.
Типы int и uint выбираются в зависимости от платформы и обычно соответствуют наиболее эффективному размеру целого числа для данной архитектуры.

**Go предоставляет несколько типов для представления целых чисел, как со знаком, так и без знака:**

```go
    // Со знаком
    int8  // 8-битное целое число со знаком. Диапазон: от -128 до 127.
    int16 // 16-битное целое число со знаком. Диапазон: от -32,768 до 32,767.
    int32 // 32-битное целое число со знаком. Диапазон: от -2,147,483,648 до 2,147,483,647.
    int64 // 64-битное целое число со знаком. Диапазон: от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.
    
    // Без знака
    uint8  // 8-битное целое число без знака. Диапазон: от 0 до 255.
    uint16 // 16-битное целое число без знака. Диапазон: от 0 до 65,535.
    uint32 // 32-битное целое число без знака. Диапазон: от 0 до 4,294,967,295.
    uint64 // 64-битное целое число без знака. Диапазон: от 0 до 18,446,744,073,709,551,615.
    
    // Платформозависимые
    int  // Целое число со знаком, размер которого зависит от архитектуры платформы (32 или 64 бита). Используется для работы с целочисленными значениями по умолчанию
    uint //Беззнаковое целое число, размер которого также зависит от архитектуры платформы.
    
    // Псевдонимы
    byte // Синоним для uint8, часто используется для представления байтов данных.
    rune // Синоним для int32, используется для представления символов Unicode.
```

## Числа с плавающей точкой

**Особенности:**
Тип float64 обеспечивает более высокую точность и является предпочтительным выбором при работе с дробными числами.
Операции с числами с плавающей точкой могут приводить к накоплению ошибок округления, поэтому следует быть внимательным при выполнении вычислений, требующих высокой точности.

**Для представления дробных чисел в Go используются следующие типы:**

```go
    float32 // 32-битное число с плавающей точкой.
    float64 // 64-битное число с плавающей точкой.
```

## Комплексные числа

**Особенности:**
Комплексные числа используются в специализированных областях, таких как научные вычисления и обработка сигналов.

**Go поддерживает комплексные числа с помощью следующих типов:**

```go
    var f complex64 = 1+2i  // Комплексное число, где действительная и мнимая части представлены типом float32.
    var g complex128 = 4+3i // Комплексное число, где действительная и мнимая части представлены типом float64.
```

## Строки

В Go строка (string) — это неизменяемая **последовательность байтов** (не рун!)

**Особенности:**
Строки могут содержать любые байты, включая нулевые и байты, представляющие символы Unicode.
Для работы с символами Unicode используется тип rune.
Строки можно конкатенировать с помощью оператора +.

Помимо обычных символов, строка в Go может содержать специальные последовательности. Все последовательности начинаются с обратного слеша. Например:

- \n — переход на новую строку,
- \t — табуляция,
- \\`— одинарная кавычка,
- \« — двойная кавычка,
- \\\ — обратный слеш.

Также строка может содержать Unicode-символы. Для этого необходимо задать последовательность символов в формате \uXXXX, где XXXX — значение символа Unicode. Например, чтобы добавить знак ₽, нужно ввести \u20BD.

```go
    var s string = "Hello, world! \u20BD" // После создания строки ее невозможно изменить

    for i, r := range s { // Итерация по рунам в строке. for range автоматически распознаёт границы рун и читает их полностью
        fmt.Printf("Руна: %U, Символ: %c\n", r, r)
        // Индексы i в for range НЕ идут подряд, потому что символы могут занимать разное количество байтов
    }

    for i := 0; i < len(s); i++ { // Итерация по байтам в строке
        fmt.Printf("Байт: %X, Символ: %c\n", s[i], s[i])
    }

    runes := []rune(s) // Преобразование строки в массив рун

```

### Как Go считывает руны из строки?

```plaintext
    Go НЕ читает фиксированное количество байтов за итерацию — он адаптируется к длине руны
```

В Go строка хранится как последовательность байтов (UTF-8), а руны (символы Unicode) могут занимать от 1 до 4 байтов. Когда мы используем for range, Go считывает целую руну за один шаг — независимо от того, занимает она 1, 2, 3 или 4 байта.

**UTF-8 — это переменно-длинная кодировка, где:**

- 1 байт используется для ASCII-символов (A, B, C, ...).
- 2 байта — для символов кириллицы (Привет).
- 3 байта — для некоторых азиатских символов (你好).
- 4 байта — для эмодзи (🚀).

**Почему Go не считывает по 2 байта за раз?**

Go не читает фиксированное количество байтов за раз! Вместо этого:

1. Первый байт каждого символа содержит информацию о его длине.
2. Go проверяет этот первый байт, чтобы определить, сколько всего байтов занимает руна.
3. Go забирает нужное количество байтов и декодирует руну.

### strings

Пакет `strings` в Go предоставляет набор функций для работы со строками. Все функции — чистые, то есть не изменяют исходную строку (в Go строки иммутабельны). **Возвращаемые значения — новые строки или результаты вычислений**.

**Основные особенности:**

- Иммутабельность строк — все преобразования создают копию.
- ASCII-ориентированность — большинство функций работает с байтами, а не с Unicode-рунами.

`ДОКУМЕНТАЦИЯ`: <https://pkg.go.dev/strings>

```go
    import "strings"
    
    // Проверка наличия подстроки
    strings.Contains("hello world", "world") // true
    strings.Contains("hello world", "WORLD") // false (регистр важен)

    // Проверка наличия хотя бы одного символа из набора
    fstrings.ContainsAny("team", "aeiou") // true (есть 'e', 'a')

    // Проверка начала и конца строки
    strings.HasPrefix("go.dev", "go") // true
    strings.HasSuffix("go.dev", "dev") // true

    // Поиск позиции подстроки (возвращает индекс или -1)
    strings.Index("chicken", "ken") // 4
    strings.Index("chicken", "egg") // -1

    // Замена подстрок
    // n = -1 — заменить все вхождения
    strings.Replace("oink oink oink", "oink", "moo", -1) // moo moo moo

    // Разделение строки по разделителю
    words := strings.Split("a,b,c", ",") // [a b c]

    // Объединение среза строк в одну
    joined := strings.Join([]string{"a", "b", "c"}, "-") // a-b-c

    // Повтор строки
    strings.Repeat("na", 2) // nana

    // Обрезка пробелов
    strings.TrimSpace("   hello   ") // "hello"

    // Обрезка конкретных символов слева и справа
    strings.Trim("...hello...", ".") // "hello"

    // Преобразование регистра
    strings.ToLower("GoLang") // golang
    strings.ToUpper("GoLang") // GOLANG

    // Сравнение без учета регистра
    strings.EqualFold("Go", "go") // true
```

## Логический тип

Логический тип данных в Go представлен типом bool и может принимать значения true или false.

**Особенности:**
Используется в условных выражениях и циклах для управления потоком выполнения программы.

```go
    var b bool = true
```

## Преобразование типов

- Приведение типов возможно только между совместимыми типами (например, int32 → int64).
- Для строк → число, всегда используется парсинг (strconv или fmt.Sscanf).
- При парсинге нужно обрабатывать ошибку (error), если строка невалидная.

Для парсинга чисел можно использовать `strconv` или `fmt.Sscanf` разница между ними:

1. strconv — специализированный парсер для чисел
   - Заточен под конвертацию строка ↔ число/булево.
   - Быстрее и проще, чем fmt.Sscanf.
   - Явно задаётся система счисления и разрядность.
   ⚠️ Парсит только одно значение за вызов.
   - Используется, когда у тебя чистая строка с числом ("42", "3.14").
2. mt.Sscanf — форматный парсер (как scanf в C)
   - Может распарсить несколько значений из строки сразу.
   - Поддерживает форматные спецификаторы (%d, %f, %s).
   ⚠️ Медленнее, чем strconv (больше логики разбора).
   - Используется, когда строка сложнее, чем просто число: "age=42 height=180".

## Константы

`Статья на тему`: <https://metanit.com/go/tutorial/2.4.php>

Константы, как и переменные, хранят некоторые данные, но в отличие от переменных значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции.

```go
    const pi float64 = 3.1415
    pi = 2.7182             // ! Ошибка

    const ( // В одном определении можно объявить разу несколько констант
        pi float64 = 3.1415
        e float64 = 2.7182
    )

    const pi, e = 3.1415, 2.7182

    // Если у константы не указан тип, то он выводится неявно на основании того значения, которым инициализируется константа

    const n = 5 //  тип untyped int - это значит, что мы можем использовать его как некоторые другие типы, например float64. Т.е. данный тип указывает, что переменная может автоматически конвертироваться в случае необходимости

    // Если определяется последовательность констант, то инициализацию значением можно опустить для всех констант, кроме первой. В этом случае константа без значения получит значение предыдущей константы
    const (
        a = 1
        b
        c
        d = 3
        f
    )
    fmt.Println(a, b, c, d, f)      // 1, 1, 1, 3, 3

```

## Массивы

`Статья`: <https://metanit.com/go/tutorial/2.8.php>

Go — это строго типизированный язык, и его массивы имеют фиксированную длину, которая указывается при объявлении.

Если обратиться к несуществующему индексу, Go выдаст ошибку во время компиляции (в отличие от Java, где это произойдет во время выполнения)

```go
    var a [5]int // Инициализация массива

    arr := [5]int{1, 2, 3} // массив из 5 элементов c частичной инициализацией [1, 2, 3, 0, 0]
    arr := [...]int{1, 2, 3, 4} // автоматическое вычисление размера

    // Итерация по массиву
    for index, value := range arr {
        fmt.Printf("arr[%d] = %d\n", index, value)
        //  * Для value создается копия оригинального значения, если его поменять, то оригинально значение не изменится
    }

    for index := range arr {
        // Итерация только по индексам массива
    }

    func modifyArray(arr [3]int) { // передается по значению, а не по ссылке => работаем с копией массива
        arr[0] = 100
    }

    // Индексы в массиве фактически выступают в качестве ключей, по которым можно обратиться к соответствующему значению. И в принципе мы можем явным образом указать, какому ключу какое значение будет соответствовать
    colors := [3]string{2: "blue", 0: "red", 1: "green"}
    fmt.Println(colors[2])      // blue

    var b = [...]int{2: 12, 2, 3, 12: 5} // [0 0 12 2 3 0 0 0 0 0 0 0 5]
```

### Итерация по указателю на массив и самому массиву

**В for range поведение зависит от типа выражения справа:**

- Если это массив ([N]T), компилятор делает копию массива для обхода. Переменная v на каждой итерации берётся из этой копии.
- Если это указатель на массив (*[N]T) или срез ([]T), копии элементов не создаются заранее; на каждой итерации v получается как a[i] — чтение текущего значения из исходного массива/среза.

```go
    // Массив vs указатель на массив
    func demo() {
        a := [8]int{1, 2, 3, 4, 5, 6, 7, 8}
        for i, v := range a { // a — КОПИЯ для обхода; v берём из копии
            if i+1 == len(a) { break }
            a[i+1] *= v      // меняем ОРИГИНАЛ a, но v остаётся "старым"
        }
        // a: [1 2 6 12 20 30 42 56]

        b := [8]int{1, 2, 3, 4, 5, 6, 7, 8}
        for i, v := range &b { // &b — указатель; v = (*&b)[i] — текущее значение
            if i+1 == len(b) { break }
            b[i+1] *= v       // теперь v уже учитывает изменения предыдущих шагов
        }
        // b: [1 2 6 24 120 720 5040 40320]
    }
```

### Стоимость копирования массивов и range в Go

В Go `массивы ([N]T)` — значимые типы. **При передаче массива в функцию создаётся копия всего массива**. Дополнительно, **если внутри функции итерироваться по самому массиву через for range** (а не по указателю/срезу), то перед началом цикла **создаётся ещё одна снимок‑копия массива для обхода**. Это не «копия на каждую итерацию», а одна дополнительная копия на весь цикл.

**Особенности:**

- Передача массива по значению ⇒ создаётся 1‑я копия (O(N) по времени и памяти).
- for range по массиву (значению) ⇒ создаёт 2‑ю копию массива (снимок для итерации), тоже O(N), однократно перед циклом.
- Итерация по указателю на массив (*[N]T) или по срезу ([]T) ⇒ копии контейнера нет; v в for i, v := range ... всё равно копия элемента на каждой итерации (это обычно дёшево).
- Индексный цикл (for i := 0; i < len(a); i++) по массиву‑значению не создаёт снимок‑копию: есть только копия параметра, но дополнительной копии для обхода нет.
- Практический вывод: для больших коллекций почти всегда используют срезы ([]T) или передают указатель на массив, если нужна фиксированная длина без лишних копий.

## Срезы

`Статья`: <https://metanit.com/go/tutorial/2.13.php>

**Срезы (slices)** — это главная структура работы с последовательностями данных в Go. В отличие от массивов, они динамически изменяемые и гораздо более удобны в использовании.

Срез — это структура, которая **ссылается на массив slice header (структуру среза)**. Он содержит:

   1. Указатель на первый элемент массива.
   2. Длину (len). - ограничивает доступ при чтении/записи: если индекс ≥ len — panic: index out of range
   3. Емкость (cap). - определяет максимальную длину, до которой можно расширить срез (append или s[:n])

### Создание

```go
    // СРЕЗЫ - Эта операция не копирует данные, а создаёт новый срез, который ссылается на тот же подлежащий массив, но с новыми len и cap

    s[low:high]      // двухпараметричная форма
    s[low:high:max]  // трёхпараметричная форма (full slice expression) позволяет уменьшить cap, чтобы защитить массив от изменений при append
    // low - Индекс, с которого начинается новый срез (включительно). Если опущен, считается 0
    // high - Индекс, до которого идёт новый срез (не включая high). Если опущен, считается len(s). 
    //  * Определяет длину нового среза: len = high - low
    // max (только в трёхпараметричной форме) - Используется для ограничения возможности роста среза через append. Если опущен,  то считается cap(s). 
    //  * Определяет ёмкость нового среза: cap = max - low


    arr := [5]int{10, 20, 30, 40, 50}
    s := arr[:] // от начала до конца — len=5, cap=5
    fmt.Println(s, len(s), cap(s)) // [10 20 30 40 50] 5 5

    // Двухпараметричная форма: [low:high]
    sub1 := s[1:4] // с индекса 1 по 3
    fmt.Println(sub1, len(sub1), cap(sub1)) // [20 30 40] 3 4
    // len = high - low = 4 - 1 = 3
    // cap = cap(s) - low = 5 - 1 = 4

    // Если опустить low — берём от начала
    sub2 := s[:3]
    fmt.Println(sub2, len(sub2), cap(sub2)) // [10 20 30] 3 5

    // Если опустить high — берём до конца
    sub3 := s[2:]
    fmt.Println(sub3, len(sub3), cap(sub3)) // [30 40 50] 3 3

    // Трёхпараметричная форма: [low:high:max]
    sub4 := s[1:3:10] // len = 3 - 1 = 2, cap = max - low = 10 - 1 = 9
    fmt.Println(sub4, len(sub4), cap(sub4)) // [20 30] 2 9

    // Через make([]тип, длина, емкость)
    //  * длина (len) — количество элементов, которые сразу доступны для использования
    //  * емкость (cap) — максимальное количество элементов, которые можно добавить без выделения новой памяти
    slice := make([]int, 4) // То же самое, что make([]int, 4, 4)
    slice := make([]int, 2, 4)
    // Через var (длинная форма)
    var slice2 []int = make([]int, 2, 5)

    fmt.Println(slice)      // [0 0]
    fmt.Println(len(slice)) // 2
    fmt.Println(cap(slice)) // 4
```

### Основные функции для работы со срезами

```go
    slice := []int{1, 2, 3, 4, 5}
    len(slice) // Получение длины среза
    cap(slice) // Получение емкости среза

    // copy() - копирует минимальное количество элементов между dest и src
    src := []int{10, 20, 30}
    dest := make([]int, len(src)) // Создаем срез нужного размера
    copy(dest, src)
    fmt.Println(dest) // [10 20 30]

    src := []int{1, 2, 3, 4, 5}
    dest := make([]int, 3) // Меньший срез
    copy(dest, src)
    fmt.Println(dest) // [1 2 3]

    // Удаление элемента из среза
    // Go не имеет встроенной функции удаления элементов
    slice := []int{1, 2, 3, 4, 5}
    index := 2 // Удаляем элемент с индексом 2 (число 3)
    slice = append(slice[:index], slice[index+1:]...)
    fmt.Println(slice) // [1 2 4 5]

    // Очистка среза
    slice := []int{1, 2, 3, 4, 5}
    slice = slice[:0] // Срез пустой, но `cap` остается прежним
    fmt.Println(slice, len(slice), cap(slice)) // [] 0 5

    // clear(s) — зануляет элементы среза на месте (Go 1.21+)
    s := []int{1, 2, 3}
    clear(s) // теперь s == []int{0,0,0}
    fmt.Println(s, len(s), cap(s)) // длина/ёмкость не меняются
```

#### append

`append` — встроенная функция, которая **ВСЕГДА** возвращает новый срез, в который добавлены элементы к исходному срезу.
Важный момент: append может вернуть срез, указывающий на тот же массив, а может создать новый массив и скопировать данные, если в старом нет места.

Особенности:

- Работает с nil-срезами — при первом append создаётся новый массив.
- Не изменяет len исходного среза напрямую — возвращает новый.
- При нехватке cap создаёт новый массив и копирует в него старые данные.
- Рост ёмкости (cap) при перевыделении — внутренний алгоритм runtime:
- Обычно cap удваивается, пока < 1024, затем растёт примерно на 25%.
- Если cap позволяет, append просто записывает элементы в текущий массив(**могут быть видны в других срезах**).

Как работает пошагово:

1. Проверка ёмкости
   - Если len(s)+len(elems) <= cap(s), места хватает → записываем в существующий массив.
   - Если места нет → выделяем новый массив с увеличенной ёмкостью, копируем данные, добавляем новые элементы.
2. Возврат нового среза
   - Новый срез ссылается на тот же или новый массив.
   - **Исходный срез (s) остаётся прежним**.

```go

    func append[S ~[]E, E any](s S, elems ...E) S // Сигнатура

    // Добавление элементов append(slice, values...)
    s := make([]int, 2, 4) // s=[0 0] len=2 cap=4
    s2 := append(s, 10) // s2=[0 0 10] len=3 cap=4
    s3 := append(s2, 20, 30) // s3=[0 0 10 20 30] len=5 cap=8 (места не хватает → новый массив)
    s2[0] = 99 // Проверим, общий ли массив:
    fmt.Println("s:", s) // s: [99 0]
    fmt.Println("s2:", s2) // s2: [99 0 10]
    fmt.Println("s3:", s3) // s3: [0 0 10 20 30] — не изменился, значит массив другой

    acc := &s2[1]
    acc.val = 100
    fmt.Println(s1, s2) // [{0}] [{0} {100}]
    s1 = append(s1, account{val: 1000}) // Данное действие ПЕРЕЗАПИШЕТ значение, которое было в массиве
    fmt.Println(s1, s2) // [{0} {1000}] [{0} {1000}]
    
    slice1 := []int{1, 2, 3}
    slice2 := []int{4, 5, 6}
    slice1 = append(slice1, slice2...) // Используем `...` для раскрытия второго среза
    fmt.Println(slice1) // [1 2 3 4 5 6]

    slice1 := []int{} // len = 0, cap = 0
    slice1 = append(slice1, 4, 5, 6) // Добавляем множество значений
    fmt.Println(slice1) // [4 5 6], len = 3, cap = 3
```

#### Расширенные операции со срезами

##### Сортировка среза (sort из sort пакета)

`ДОКУМЕНТАЦИЯ`: <https://pkg.go.dev/sort>

```go
    import "sort"

    slice := []int{3, 1, 4, 1, 5, 9, 2}
    sort.Ints(slice) // Для сортировки чисел
    fmt.Println(slice) // [1 1 2 3 4 5 9]

    strs := []string{"banana", "apple", "cherry"}
    sort.Strings(strs) // Для строк
    fmt.Println(strs) // [apple banana cherry]

    floats := []float64{3.1, 2.4, 5.6}
    sort.Float64s(floats)
    fmt.Println(floats) // [2.4 3.1 5.6]
```

##### Пакет slices (Go 1.21+)

`ДОКУМЕНТАЦИЯ`: <https://pkg.go.dev/slices>

Пакет "slices" содержит обобщённые функции для []T. Для сравнения и сортировки есть две версии: «естественная» (для упорядочиваемых типов) и с функцией-компаратором (*Func)

```go
    import (
        "slices" // набор утилит для срезов (Go 1.21+)
        "cmp" // универсальная компарация значений (Go 1.21+)
    ) 
    
    // СРАВНЕНИЕ/ПРОВЕРКИ
    
    // slices.Equal(x, y) — элементное равенство
    x := []int{1, 2, 3}
    y := []int{1, 2, 3}
    z := []int{1, 2, 4}
    fmt.Println(slices.Equal(x, y)) // true
    fmt.Println(slices.Equal(x, z)) // false

    // slices.EqualFunc(x, y, eq) — равенство по предикату
    type P struct{ X, Y int }
    eq := func(a, b P) bool { return a.X == b.X && a.Y == b.Y }
    a := []P{{1,2}, {3,4}}
    b := []P{{1,2}, {3,4}}
    fmt.Println(slices.EqualFunc(a, b, eq)) // true

    // slices.Compare(x, y) — лексикографическое сравнение; использует <, >
    fmt.Println(slices.Compare([]int{1,2}, []int{1,2})) // 0
    fmt.Println(slices.Compare([]int{1,2}, []int{1,3})) // <0
    
    // ПОИСК/ПРОВЕРКА СОДЕРЖИМОГО

    // slices.Index(s, v) — индекс первого вхождения или -1
    s := []string{"go", "java", "go"}
    fmt.Println(slices.Index(s, "go"))   // 0
    fmt.Println(slices.Index(s, "rust")) // -1

    // slices.IndexFunc(s, pred) — индекс по предикату
    s := []int{10, 21, 32}
    odd := func(x int) bool { return x%2 == 1 }
    fmt.Println(slices.IndexFunc(s, odd)) // 1

    // slices.Contains(s, v) / ContainsFunc(s, pred) — содержит ли
    s := []int{1, 2, 3}
    fmt.Println(slices.Contains(s, 2)) // true
    fmt.Println(slices.ContainsFunc(s, func(x int) bool { return x > 5 })) // false

    // МОДИФИКАЦИИ С КОПИРОВАНИЕМ (НЕ встроенные append/copy)

    c := slices.Clone(s) // slices.Clone(s) — поверхностная копия
    
    s := []int{1, 2, 3, 4}
    s = slices.Replace(s, 1, 3, 9, 9) // -> [1, 9, 9, 4]

    // slices.Replace(s, i, j, repl...) — заменить подотрезок [i:j)
    s := []int{1, 2, 3, 4}
    s = slices.Replace(s, 1, 3, 9, 9) // -> [1, 9, 9, 4]

    // slices.Insert(s, i, vals...) — вставка перед индексом i
    s := []int{1, 4}
    s = slices.Insert(s, 1, 2, 3) // -> [1, 2, 3, 4]

    // slices.Delete(s, i, j) — удалить подотрезок [i:j)
    s := []int{1, 2, 3, 4, 5}
    s = slices.Delete(s, 1, 4) // удалит 2,3,4 -> [1,5]
    
    // РАБОТА С РАЗМЕРОМ/ЁМКОСТЬЮ
    
    // slices.Grow(s, n) — гарантирует cap(s) >= len(s)+n; может вернуть новый срез
    s := []int{1, 2, 3}
    s = slices.Grow(s, 1000) // полезно перед большим количеством append

    // slices.Clip(s) — усечь ёмкость до длины (cap = len)
    s := make([]int, 0, 100)
    s = append(s, 1, 2, 3)
    s = slices.Clip(s) // освобождает лишнюю ёмкость
    fmt.Println(len(s), cap(s)) // cap == 3

    // УДАЛЕНИЕ ДУБЛИКАТОВ
    
    // slices.Compact(s) — удаляет подряд идущие дубликаты (для сортированных — убирает повторы)
    s := []int{1,1,2,2,2,3,3}
    s = slices.Compact(s) // -> [1,2,3]

    // slices.CompactFunc(s, eq) — «схлопывает» подряд равные по предикату
    type P struct{ X, Y int }
    eq := func(a, b P) bool { return a.X == b.X && a.Y == b.Y }
    s := []P{{1,2},{1,2},{2,2}}
    s = slices.CompactFunc(s, eq) // -> [{1,2},{2,2}]

    // СОРТИРОВКА И ПРОВЕРКА ПОРЯДКА

    // slices.Sort(s) — сортировка по возрастанию (для «сравнимых» типов)
    s := []int{3, 1, 2}
    slices.Sort(s) // -> [1,2,3]

    // slices.SortFunc(s, less) — сортировка по функции
    type U struct{ Name string; Age int }
    less := func(a, b U) int {
        // Сначала по Age, затем по Name
        if c := cmp.Compare(a.Age, b.Age); c != 0 { return c }
        return cmp.Compare(a.Name, b.Name)
    }
    s := []U{{"Bob", 30}, {"Ann", 20}, {"Ann", 25}}
    slices.SortFunc(s, less)

    // slices.IsSorted(s) / IsSortedFunc(s, less) — проверка отсортированности
    s := []int{1, 2, 3}
    fmt.Println(slices.IsSorted(s)) // true

    // БИНАРНЫЙ ПОИСК (для отсортированных срезов)

    // slices.BinarySearch(s, target) — индекс и найдено/нет
    s := []int{1, 3, 5, 7}
    i, found := slices.BinarySearch(s, 5) // i=2, found=true

    // slices.BinarySearchFunc(s, x, cmp) — бинарный поиск с компаратором
    type W struct{ V string }
    s := []W{{"a"},{"c"},{"d"}}
    i, found := slices.BinarySearchFunc(s, W{"c"}, func(a, b W) int {
        return cmp.Compare(a.V, b.V)
    })
```

### Как работает выделение памяти для срезов?

Когда мы создаем срез через make(), Go внутри выделяет массив нужного размера и создает ссылку на этот массив:

```plaintext
    Пример работы make([]int, 3, 5) в памяти
    Массив в памяти:  [ 0  0  0  -  - ]  (размер 5, cap=5)
    Срез указывает на: [ 0  0  0 ]
```

Если добавить новый элемент через append(), он попадет в резерв

**Когда выделяется новый массив?**

Go выделяет новый массив только если добавленный элемент превышает текущую cap(slice).

- Когда cap(slice) > len(slice)
Если длина (len) меньше емкости (cap), новый элемент просто добавляется в свободное место. Выделения памяти не происходит.

- Когда cap(slice) == len(slice)
Если len(slice) уже равно cap(slice), новый элемент не помещается, поэтому Go:
  1. Создаёт новый массив с увеличенной cap.
  2. Копирует все старые элементы в новый массив.
  3. Добавляет новый элемент в конец.
  4. Возвращает ссылку на новый массив.

**Когда создается новый массив и ссылка на него передается в переменную, старый массив остается в памяти, пока на него есть ссылки.**

**Как вычисляется новый размер массива (cap)?**

Алгоритм роста емкости (cap) в Go работает следующим образом:

1. Если cap = 0, то при добавлении нового элемента или ряда элементов будет выделено необходимое кол-во памяти для записи и cap будет равен len
2. Если cap < 1024, то новая cap = 2 * старая cap (удвоение).
3. Если cap ≥ 1024, то новая cap увеличивается примерно на 25% (не удваивается, чтобы не расходовать слишком много памяти).

**Также при выделении памяти применяется механизм выравнивания памяти, который может изменить количество выделенных ячеек памяти:**

```go
    var slice1 []int32 // len = 0, cap = 0
    slice1 = append(slice1, 4, 5, 6) // len = 3, cap = 3
    slice1 = append(slice1, 4)
    fmt.Println(len(slice1), cap(slice1)) // len = 4, cap = 4   
    
    var slice2 []int64 // len = 0, cap = 0
    slice2 = append(slice2, 4, 5, 6) // len = 3, cap = 3
    slice2 = append(slice2, 4)
    fmt.Println(len(slice2), cap(slice2)) // len = 4, cap = 6
```

## Map

`map` в Go — это встроенный ассоциативный контейнер (словарь), который хранит пары ключ–значение.  
Ключи должны быть сравнимыми (comparable) типами, т.е. поддерживать оператор `==` и `!=` (например: `string`, `int`, `bool`, `struct` без срезов и map внутри).  
Значения могут быть любыми типами, включая срезы, структуры, интерфейсы и даже другие карты.

**Особенности:**

- **Хеш-таблица под капотом** — ключи хэшируются, и хеш используется для поиска значения.
- **Амортизированная сложность O(1)** для операций добавления, получения и удаления.
- **Неупорядоченность** — порядок обхода элементов не гарантирован и может меняться при каждой итерации.
- **Нулевая инициализация** — переменная типа `map` по умолчанию имеет значение `nil`, и с ней нельзя работать без инициализации.
- **Автоматическое увеличение размера** — при заполнении внутренние бакеты пересоздаются и перераспределяются.

**Как работает под капотом:**

```plantext
                       hmap (заголовок карты)
+-------------------------------------------------------+
| count | flags | B | hash0 | buckets | oldbuckets | ...|
|              (2^B бакетов)            (во время grow) |
+--------------------------+----------------------------+
                           |
                           v
                 buckets: массив bmap (плотно)
        +-------------------+-------------------+-------------------+
 idx=0  |      bmap #0      |      bmap #1      |      bmap #2      |  ...  bmap #(2^B-1)
        +---------+---------+---------+---------+---------+---------+
                  |                   |                   |
                  v                   v                   v

 bmap (основной бакет):
 +--------------------------------------------------------------+
 | tophash[8] | keys[8] (плотный блок) | values[8] | overflow → |
 +--------------------------------------------------------------+
                                                 |
                                                 v
                                    overflow цепочка (в куче, НЕ в buckets)
                                    +--------------------+        +--------------------+
                                    |  bmap_ov1          |  -->   |  bmap_ov2          |  -->  nil
                                    | tophash[8]         |        | tophash[8]         |
                                    | keys[8]            |        | keys[8]            |
                                    | values[8]          |        | values[8]          |
                                    | overflow → bmap_ov2|        | overflow → nil     |
                                    +--------------------+        +--------------------+
```

- Go хранит карту как **массива бакетов** (buckets), каждый бакет — набор записей (часть хеша + ключ + значение).
- Для поиска значения:
  1. Вычисляется хеш ключа.
  2. Определяется бакет по нижним битам хеша. При помощи остатка отделения хеш % количество бакетов = номер бакета
  3. Ищется совпадение ключа внутри бакета, сравнивается tophash и с частью кеша, если есть совпадение, то проверяется ключ, если и он совпал, то получается значение
  4. Если совпадения не найдено, то просматривается бакет, ссылка на который указана в конце бакета.
- При переполнении бакета создаются "overflow buckets". Ссылка на который хранится в конце каждого бакета
- При росте числа элементов Go **удваивает** количество бакетов и перераспределяет ключи.

### Основные функции и операции

```go
    import "fmt"

    // Инициализация
    m := make(map[string]int, 10) // Пустая карта но с выделенным размером, чтобы избежать пересоздание мапы
    m2 := map[string]int{"a": 1} // Литерал

    m["key1"] = 10 // Добавляет или заменяет значение

    // Получение значения
    val := m["key1"] // если ключа нет — вернется zero value
    val, ok := m["key2"] // ok == false, если ключ отсутствует

    delete(m, "key1") // Удаление безопасно вызывать даже для несуществующего ключа

    count := len(m) // Число пар ключ–значение

    // Итерация
    for k, v := range m {
        fmt.Println(k, v)
    }
```

#### maps (Go 1.21+)

Пакет maps был добавлен в Go 1.21 и предоставляет набор универсальных функций для работы с картами (map).  
Он является частью стандартной библиотеки и работает с дженериками, что позволяет использовать его с любыми типами ключей и значений, поддерживаемыми в Go.

`ДОКУМЕНТАЦИЯ`: <https://pkg.go.dev/maps>

```go
    import "maps"

    m1 := map[string]int{"a": 1, "b": 2}
    m2 := maps.Clone(m1) // Создаёт полную копию карты.

    maps.Copy(dst, src)  // Копирует все пары ключ-значение из src в dst
    //  * Если ключ уже есть в dst, его значение перезапишется

    maps.Clear(m) // Удаляет все элементы карты, оставляя её пустой

    isEqual := maps.Equal(m1, m2) // Сравнивает две карты по ключам и значениям

    equal := maps.EqualFunc(m1, m2, func(a, b []int) bool) // Сравнивает карты с использованием кастомной функции сравнения значений

    keys := maps.Keys(m) // Возвращает срез ключей карты
    //  * Порядок ключей не гарантируется
    vals := maps.Values(m) // Возвращает срез значений карты
    //  * Порядок ключей не гарантируется

```

### Таблица zero value для разных типов

| Тип            | Zero value                        |
| -------------- | --------------------------------- |
| `int`, `int64` | `0`                               |
| `float64`      | `0.0`                             |
| `bool`         | `false`                           |
| `string`       | `""` (пустая строка)              |
| `pointer`      | `nil`                             |
| `slice`        | `nil`                             |
| `map`          | `nil`                             |
| `chan`         | `nil`                             |
| `struct`       | все поля — zero value своих типов |
| `interface`    | `nil`                             |

### Новая реализация map в (Go 1.24+)

В Go 1.24 реализация встроенного типа map полностью переписана: вместо «бакеты + цепочки overflow» теперь используется вариант «Swiss Table» — это открытая адресация с «группами» по 8 слотов и 64‑битным управляющим словом (control word) на группу. Это даёт быстрый отбор кандидатов по 7‑битному «отпечатку» хеша (h2) и позволяет «проверять» все 8 слотов группы за раз, векторизованно (SIMD), прежде чем сравнивать полноценно ключи. Официальное описание — в блоге Go.

**Как теперь это работает:**

1. Хеш разбивается на две части: старшие биты h1 выбирают группу, младшие 7 бит h2 записываются в control word группы.
2. Выбор таблицы (directory / extendible hashing): берутся несколько старших бит h1 — их количество определяется текущей «глубиной» каталога. Эти биты дают индекс таблицы. Когда отдельная таблица переполняется, она сплитится на две, и число используемых старших бит увеличивается, то есть часть ключей начинает попадать в «новую» таблицу.
3. Выбор стартовой группы внутри выбранной таблицы: оставшиеся биты h1 (в классической Swiss Table — просто h1 % group_count, где group_count — степень двойки) дают индекс первой группы для пробинга. Далее применяется открытая адресация: если группа/слот заняты, последовательно пробуем следующую группу и т. д. Для фильтрации кандидатов используем h2 из control word.
4. Поиск/вставка: сначала «маской» сравнивают h2 со всеми 8 байтами control word — сразу получают индексы слотов‑кандидатов; после этого уже точечно сверяют ключи. Если группа забита, пробинг идёт к следующей группе.

Максимальный коэффициент заполнения стал выше (типично 7/8 ≈ 87.5% для групп), поэтому при том же числе элементов нужно меньше памяти.

**Control word (64 бит)** - 8 байт, каждый из которых содержит h2 (7 старших бит хеша) + 1 бит (самый старший), который указывает на заполненность данного слота. При вставке смотрится он и проверяется занят слот или нет, если он 1, то слот пустой и в него записывается значение а в оставшиеся 7 битов в Control word записывается h2.

**Схема нового устройства map:**

```plantext
Directory (каталог таблиц, каждая ~1024 элементов)
+-----------------+      +-----------------+
|   Table T0      |      |   Table T1      |
| (группы по 8)   |      | (группы по 8)   |
+--------+--------+      +--------+--------+
         |                        |
         |                        |
   +-----+-----+            +-----+-----+
   |  Group 0  |            |  Group 0  |
   |-----------|            |-----------|
   | Control   |            | Control   |
   | word[8]   |            | word[8]   |
   | Keys[8]   |            | Keys[8]   |
   | Values[8] |            | Values[8] |
   +-----------+            +-----------+
         |
   +-----+-----+
   |  Group 1  |
   |-----------|
   | Control   |
   | word[8]   |
   | Keys[8]   |
   | Values[8] |
   +-----------+
```

**Как решили главную «болячку» старой реализации:**

Старая мапа держала основной массив бакетов и на переполнении цепляла overflow‑бакеты; из‑за этого:
• память фрагментировалась, возрастали кеш‑промахи на проходе по цепочкам;
• при инкрементальном росте одновременно жили и «старые» бакеты (oldbuckets), и «новые», что давало дополнительный оверхед памяти;
• длинные цепочки overflow ухудшали асимптотику и «хвостовые» задержки.
Новая схема с открытой адресацией и control word устраняет цепочки overflow и резко улучшает локальность доступа.

## Struct

`struct` — это пользовательский тип данных в Go, который группирует несколько полей (переменных) под одним именем. Он служит для представления сложных объектов с разными свойствами. Аналог в Java — класс без методов и наследования.

**Особенности:**

- Нет классов и наследования — struct описывает только данные, а методы можно привязывать к нему отдельно.
- Все поля по умолчанию имеют нулевые значения (0 для чисел, "" для строк, nil для ссылочных типов).
- Экспорт полей: имя поля с заглавной буквы — поле доступно из других пакетов; с маленькой — приватно.
- Поддержка анонимных (встраиваемых) полей — аналог упрощённой композиции.
- Сравнение: два struct можно сравнить с ==, если все их поля сравнимы.
- Передача по значению — при присвоении или передаче копируется весь struct, но можно передавать указатель для работы с оригиналом.
- Нет конструкторов — инициализация через литералы или отдельные функции-фабрики.

```go
    // Определение структуры
    type Address struct {
        City string
        Zip  string
    }

    // Встраиваем Address в User (анонимное поле)
    type User struct {
        Name string  // экспортируемое поле
        age  int     // приватное поле (только внутри пакета)
        Address // Встраиваем Address в User (анонимное поле)
    }

    u := User{
        Name: "Alice",
        Address: Address{City: "London", Zip: "E1 6AN"},
    }
    fmt.Println(u.City) // доступ напрямую к полю встраиваемой структуры

    // Можно указывать не все поля (остальные будут нулевыми)
    u2 := User{Name: "Bob"}
```

### Композиция (встраивание) Struct в Go

`Композиция в Go` — это возможность встраивать один `struct` в другой без явного объявления имени поля. Такой встроенный тип называется анонимным полем.
Под капотом это не наследование, а именно поле внутри структуры, к которому Go даёт упрощённый синтаксис доступа.

**Особенности:**

- **Встроенный тип становится полем структуры** — память выделяется прямо внутри родительского объекта, а не через указатель.
- Доступ к полям и методам встроенного типа без префикса — компилятор разворачивает обращение.
- Нет переопределения как в Java — если имена совпадают, используется поле/метод верхнего уровня.
- Можно встраивать несколько структур — при конфликте имён нужно указывать имя поля явно.
- Методы встроенной структуры также доступны напрямую — компилятор "проксирует" вызовы.

```go
    type A struct{ Name string }
    type B struct{ Name string }
    type Address struct { City string}

    func (a Address) FullAddress() string {
        return a.City
    }

    type User struct {
        Name string
        Address // анонимное поле
        A
        B
    }

    // Доступ без явного обращения к Address
    fmt.Println(u.City)          // "London"
    fmt.Println(u.FullAddress()) // "London" — метод Address доступен напрямую
    // u.Name => Ошибка: неоднозначность
    fmt.Println(u.A.Name) // "From A"
```

По сути, это не магия и не наследование, а поле с автоматическим делегированием доступа.
Можно считать, что это синтаксический сахар, который избавляет от лишнего кода типа u.Address.City

### Методы, привязанные к структурам

Метод в Go — это функция с получателем (receiver). Получатель указывает, к какому типу «привязан» метод. Методы можно объявлять для любой именованной пользовательской (не интерфейсной) сущности в том же пакете: struct, type MyInt int, type Alias SomeType

`ДОКУМЕНТАЦИЯ:` <https://go.dev/ref/spec#Method_declarations>

Получатель (receiver) бывает двух видов: по значению (T) и по указателю (*T).
Выбор влияет на копирование, возможность изменять состояние и на method set.

`method set`- это формальное определение доступных методов у типа. При прямом вызове методов на struct или struct компилятор может «обойти» ограничения method set с помощью автоадресации и авторазыменования. При **проверке соответствия интерфейсу** — **компилятор** не применяет эту магию и **строго сравнивает method set типа с методами интерфейса**

**Особенности:**

- Method set определяет соответствие интерфейсам (работает только для интерфейсов):
  - у типа T доступны только методы с получателем T;
  - у типа *T — и методы T, и методы \*T.
- Автоадресация/разыменование при вызове: v.M() вызывает (&v).M() если нужно, и наоборот — компилятор подставит */&, если это корректно и значение адресуемо.
- Никакого наследования и override: методы нельзя переопределять, но они продвигаются (promoted) через встраивание (композицию).
- Методы можно объявлять на любых именованных типах, не только на struct: например, type Bytes []byte.
- Нельзя объявлять методы на указателях и интерфейсах: получатель должен быть именованным типом, а не *MyType/interface{}.

```go
    type User struct {
        Name string
        hits int
    }

    // Value receiver: работает с копией; состояние исходника не меняет
    func (u User) Display() string {
        // u — копия, изменение u не затронет оригинал
        return fmt.Sprintf("User(%s,hits=%d)", u.Name, u.hits)
    }

    // Pointer receiver: может менять состояние оригинала
    func (u *User) Inc() {
        if u == nil { // nil-устойчивость — хорошая практика
            return
        }
        u.hits++
    }

    u := User{Name: "Alice"}
    u.Display() // ok: value receiver

    u.Inc() // компилятор подставит &u автоматически
    &u.Display() // компилятор подставит (*u) автоматически

    // Подводные камни копирования с value receiver 

    type Bag struct{ items []string }

    // Value receiver: копируется только дескриптор среза (len/cap/ptr).
    // Мутация элементов изменит общий буфер, но присваивание нового среза — нет.
    func (b Bag) AppendUnsafe(x string) Bag {
        b.items = append(b.items, x) // может аллоцировать новый буфер и разорвать связь
        return b
    }

    // Pointer receiver: явно меняем оригинал
    func (b *Bag) Append(x string) {
        b.items = append(b.items, x)
    }
```

### struct tags

`Теги (struct tags)` — это строковые метки, которые можно привязать к каждому полю структуры.
Они не влияют на поведение программы напрямую, а используются внешними библиотеками или стандартной библиотекой через reflection (reflect пакет)

Теги используются для сериализации/десериализации, работы с БД, валидации, генерации кода.

**Особенности:**

- Тег задаётся в обратных кавычках (`...`) сразу после объявления поля.
- Тег — строка вида key:"value" (может быть несколько пар key/value через пробел).
- Доступ к тегу осуществляется через reflection: reflect.TypeOf(struct).Field(i).Tag.Get("key").
- Тег можно не задавать — тогда библиотека использует имя поля по умолчанию.

```go
    // Структура с тегами
    type User struct {
        ID    int    `json:"id" db:"user_id"` // Поле будет сериализовано как id, а не ID
        Name  string `json:"name,omitempty" validate:"required"` // omitempty убирает поле из JSON, если оно пустое
        Email string `json:"email"`
        A string `json:"-"` // Поле исключается из JSON
    }

    // --- JSON ---
    data, _ := json.Marshal(u)
    fmt.Println(string(data)) 
    // {"id":1,"name":"Alice"} — поле Email опущено (пустое значение)

    // --- Reflection ---
    t := reflect.TypeOf(u)
    field, _ := t.FieldByName("Name")
    fmt.Println(field.Tag.Get("json"))     // "name,omitempty"
    fmt.Println(field.Tag.Get("validate")) // "required"
```

## Интерфейсы

`Интерфейсы в Go` — это абстрактный тип, который определяет набор методов без их реализации. Любой тип (структура, встроенный тип и даже указатель), который реализует все методы интерфейса, автоматически считается реализующим этот интерфейс

Особенности:

- Автоматическая реализация — не нужно явно указывать, что структура реализует интерфейс (в отличие от Java с implements).
- Набор методов — интерфейс описывает только сигнатуры методов. Никакой частичной реализации.
- Можно использовать в качестве параметров функций для абстрагирования поведения.
- В Go **интерфейс считается реализованным только тогда, когда тип реализует все методы**, объявленные в интерфейсе. **Если реализован хотя бы один метод, но не все — компилятор не будет считать этот тип реализацией интерфейса**.
- **Одна реализация метода покрывает все интерфейсы, которые требуют ровно этот метод с той же сигнатурой**. Как только сигнатуры расходятся — это разные методы, и удовлетворить оба интерфейса одним типом в Go невозможно без переименования или пересмотра дизайна интерфейсов.

```go
    // Интерфейс с одним методом
    type Greeter interface {
        Greet() string
    }

    // Метод для структуры User
    func (u User) Greet() string {
        return "Hello, " + u.Name
    }

    // Функция принимает интерфейс, а не конкретный тип
    func SayHello(g Greeter) {
        fmt.Println(g.Greet())
    }

    SayHello(user) // В функцию можно передать User, так как он реализует интерфейс Greeter

    
    func PrintAny(v interface{}) {} // Пустой интерфейс — может принимать любой тип
    func PrintAny(v any) {} // С Go 1.18+

    // Вложение интерфейсов: дублирующиеся одинаковые методы — нормально
    // (требования объединяются без конфликта).

    type Reader interface {
        Read(p []byte) (int, error)
    }

    type Closer interface {
        Close() error
    }

    // io.ReadCloser аналогичен этому объединению:
    // interface { Read(p []byte) (int, error); Close() error }
    type ReadCloser interface {
        Reader
        Closer
    }
```

### Method set и Type set

`Method set (набор методов)` - Это список методов, которые тип обязан реализовать, чтобы удовлетворять интерфейсу
`Type set (набор типов)` - Это список допустимых подлежащих типов, которые могут участвовать в generic. Записывается через | и ~

```go
    type Stringer interface {
        String() string // // Любой тип, у которого есть метод String() string — реализует этот интерфейс.
    }

    type Number interface {
        ~int | ~float64 // Просто компилятор проверяет: «T — это int, float64 или их именной аналог? Тогда подходит»
    }

    // Можно смешивать оба механизма
    type WithID interface {
        ~int | ~string // типовое ограничение
        ID() string    // методное ограничение
    }
    // Итог: подойдут только именованные типы с underlying int или string, у которых реализован метод ID()
```

## error

**В Go ошибки** — это значения (тип error), которые явно возвращаются из функций и обрабатываются вызывающим кодом. Исключений как в Java нет. «Паника» (panic) — механизм аварийного завершения выполнения; её можно перехватить через recover, но это применяется точечно.

**Сентинел-ошибка** — это предварительно объявленное константоподобное значение error (обычно экспортируемая переменная), по которому код распознаёт класс ситуации (например, ErrNotFound).

`ДОКУМЕНТАЦИЯ`: <https://pkg.go.dev/errors>

```go
    import (
        "errors"
        "fmt"
    )

    var ErrNotFound = errors.New("not found") // Синтенел-ошибка
    
    errors.Is(err, ErrNotFound) // Сопоставляет ошибки (учитывает обёртки). Проверяет, встречается ли конкретная ошибка (или значение) в цепочке обёрток.
    //  * Если нужна просто проверка на «этот класс ошибки»

    var myErr *ValidationError
    errors.As(err, &myErr) // Ищет в цепочке первую ошибку указанного типа, записывает её в переданный указатель и возвращает true
    //  * Если нужно достать поля или методы ошибки
    
    err := fmt.Errorf("load %q: %w", path, rootErr) // Оборачивание ошибок контекстом (%w) и разворачивание
    rootErr := errors.Unwrap(err)    // Явная развёртка на один уровень

```

### Оборачивание

**Оборачивание (wrapping)** — это механизм, позволяющий добавить контекст к уже существующей ошибке, сохранив доступ к её исходному значению через цепочку Unwrap.
Работает только при использовании %w в fmt.Errorf или при реализации своего метода Unwrap() в типе ошибки.

Это позволяет:

- передать дополнительную информацию (контекст: что делала функция, с какими данными)
- при этом не потерять возможность распознать исходный класс ошибки (errors.Is / errors.As будут видеть цепочку).

Как это работает:

1. Компилятор
    При fmt.Errorf("msg: %w", err) под капотом создаётся объект типа *wrapError (внутренний тип в пакете fmt), который:
    - реализует Error() string (возвращает форматированную строку)
    - реализует Unwrap() error (возвращает переданную причину err).

2. Цепочка разворачивания
    errors.Is и errors.As умеют:
    - вызывать Unwrap() рекурсивно, пока не дойдут до nil или совпадения;
    - работать как с Unwrap() error, так и с Unwrap() []error (множественная развёртка для errors.Join).

### Собственные ошибки

В Go любая ошибка — это значение, реализующее интерфейс :

```go
    type error interface {
        Error() string
    }
```

Чтобы сделать свой тип ошибкой, нужно написать метод **Error() string**

```go
    type ValidationError struct {
        Field string
        Msg   string
    }

    func (e *ValidationError) Error() string {
        return fmt.Sprintf("invalid %s: %s", e.Field, e.Msg)
    }
```

### Работа с паникой (panic)

`Паника (panic)` — это аварийное завершение текущей горутины с разворачиванием стека и выполнением defer. Её можно перехватить только с помощью recover внутри отложенной функции. Применяется для программных ошибок, нарушений инвариантов и «невозможных» состояний — не для ожидаемых пользовательских ошибок (там нужен error)

Особенности:

- panic → размотка стека + defer. Все отложенные функции выполнятся (LIFO), затем паника пойдёт выше по стеку.
- recover работает только в defer и в той же горутине. Вне defer вернёт nil и паника не перехватится.
- Тип recover — any. Часто это string (из panic("msg")) или error (из panic(err)).
- Граничные зоны (boundaries). Идиоматично перехватывать панику на границе горутины, main или в HTTP‑middleware, логировать и конвертировать в 500/error.
- Можно «перебросить» панику. Перехватили → залогировали/почистили → panic(r) снова.
⚠️ Не используйте panic вместо error. Для ожидаемых ситуаций — явный возврат ошибки.
⚠️ Паника в безымянной горутине завершит программу, если её не перехватить внутри этой горутины.

```go
    panic("fatal invariant broken") //  Базовая паника - немедленно завершит работу программы


    func safeRun(fn func()) (recovered any) { // Правильный перехват: recover только в deferred-функции
        defer func() {
            if r := recover(); r != nil {
                log.Printf("panic recovered: %v", r)
                recovered = r
            }
        }()
        fn()
        return nil
    }

    r := safeRun(func() {
        panic("boom")
    })


    func must() { // Перехват с логированием стека и повторной паникой (re-panic)
        defer func() {
            if r := recover(); r != nil {
                log.Printf("panic: %v\n%s", r, debug.Stack()) // подробный стек
                panic(r) // пробрасываем дальше, если так задумано
            }
        }()
        panic("deep bug")
    }
```
