# Basic Syntax

- [Basic Syntax](#basic-syntax)
  - [Переменные](#переменные)
  - [Арифметические операции](#арифметические-операции)
    - [Стандартные математические операторы](#стандартные-математические-операторы)
    - [Битовые операции](#битовые-операции)
  - [Условные конструкции](#условные-конструкции)
    - [if-else](#if-else)
    - [switch](#switch)
      - [Type Switch](#type-switch)
    - [Циклы](#циклы)
  - [Type Alias](#type-alias)
  - [Fanctions](#fanctions)
    - [Параметры функции](#параметры-функции)
    - [Функции как значения и анонимные функции](#функции-как-значения-и-анонимные-функции)
  - [Указатели](#указатели)
  - [defer](#defer)
  - [Перечисления (enum)](#перечисления-enum)
  - [Generics](#generics)
    - [Generic struct](#generic-struct)

## Переменные

`Статья на тему`: <https://metanit.com/go/tutorial/2.2.php>

```go
    // Объявление переменной с указанием типа
    var a int = 0;
    var c string; // будет использовано значение по умолчанию

    // Краткая форма объявления (:=)
    // Когда используется :=, компилятор Go автоматически выводит тип переменной на основе присваиваемого значения

    i := 10 → int
    f := 3.14 → float64
    s := "Hello" → string
    b := true → bool

    // Пакетная инициализация
    a, b := 10, "Go" // a - int, b - string
    x, y := 3.14, 2  // x - float64, y - int

    var a, b int = 10, 20
    var x, y string = "Hello", "World"
    var p, q float64 = 3.14, 2.71
```

## Арифметические операции

`Статья на тему`: <https://metanit.com/go/tutorial/2.5.php>

### Стандартные математические операторы

**!Важно: Деление int / int всегда дает int, дробная часть отбрасывается!**

```go
    a := 10 + 5   // 15
    b := 10 - 3   // 7
    c := 10 * 2   // 20
    d := 10 / 3   // 3 (целочисленное деление!)
    e := 10 % 3   // 1 остаток от деления

    // Чтобы получить float при делении, оба операнда должны быть float64
    f := 10.0 / 3.0 // 3.3333333333333335
```

### Битовые операции

`Статья на тему`: <https://metanit.com/go/tutorial/2.7.php>

```go
    a := 5  // 0101 (в двоичной системе)
    b := 3  // 0011

    fmt.Println(a & b)  // 1  (0001) & - побитовое AND
    fmt.Println(a | b)  // 7  (0111) | - побитовое OR
    fmt.Println(a ^ b)  // 6  (0110) ^ - побитовое XOR
    // &^ - побитовое AND NOT (очистка битов)
    fmt.Println(a << 1) // 10 (1010) сдвиг влево на 1 бит  << - побитовый сдвиг влево
    fmt.Println(a >> 1) // 2  (0010) сдвиг вправо на 1 бит  >> - побитовый сдвиг вправо
```

## Условные конструкции

`Статья на про логические операции`: <https://metanit.com/go/tutorial/2.6.php>

### if-else

```go
    if условие {
        // код если условие истинно
    } else if другое_условие {
        // код если другое_условие истинно
    } else {
        // код если ни одно условие не сработало
    }

    age := 18

    if age < 18 {
        fmt.Println("Несовершеннолетний")
    } else if age == 18 {
        fmt.Println("Только исполнилось 18!")
    } else {
        fmt.Println("Совершеннолетний")
    }

    if r := recover(); r != nil { // объединяет объявление переменной и проверку условия в одном выражении
        // ...
    }
```

### switch

switch **работает быстрее**

**Фишка Go:** switch не требует break, он сам выходит после выполнения case.

```go
    switch выражение {
    case значение1:
        // код
    case значение2:
        // код
    default:
        // код по умолчанию
    }

    day := "понедельник"

    switch day {
    case "понедельник":
        fmt.Println("Начало недели")
    case "пятница":
        fmt.Println("Почти выходные!")
    default:
        fmt.Println("Обычный день")
    }

    a := 5
    switch(a+3) { // В условии может содержаться выражение, важно, чтобы оно возвращало значение
        case 9: fmt.Println("a = 9")
        case 8: fmt.Println("a = 8")
        case 7: fmt.Println("a = 7")
        case 6, 5, 4: 
            fmt.Println("a = 6 или 5 или 4, но это не точно")
        default: 
            fmt.Println("значение переменной a не определено")
    }
```

#### Type Switch

`Type switch` — это специальная форма switch, которая позволяет выполнять разные действия в зависимости от конкретного динамического типа значения, хранящегося в интерфейсе

Type switch можно применять только к значениям интерфейсного типа (interface{}, any, пользовательские интерфейсы).

```go
    // Type assertion: проверяем один тип
    if s, ok := x.(string); ok { // Проверяет, является ли x типом string
        fmt.Println("строка:", s)
    }

    // Пример простого type switch
    func PrintAny(x any) {
        switch v := x.(type) { // v получает конкретный тип
        case int, int8, int16, int32, int64,
            uint, uint8, uint16, uint32, uint64,
            float32, float64: // Пример комбинирования нескольких типов
            fmt.Println("numeric:", v)
        case string:
            fmt.Println("string:", v)
        case bool:
            fmt.Println("bool:", v)
        default:
            fmt.Println("неизвестный тип")
        }
    }

    // Пример с интерфейсами
    type Stringer interface {
        String() string
    }

    func Describe(x any) {
        switch v := x.(type) {
        case Stringer: // если реализует интерфейс Stringer
            fmt.Println("реализует Stringer:", v.String())
        case fmt.Stringer: // стандартный интерфейс
            fmt.Println("fmt.Stringer:", v.String())
        case nil:
            fmt.Println("nil значение")
        default:
            fmt.Printf("тип %T, значение %v\n", v, v)
        }
    }
```

### Циклы

**!В Go есть только один вид цикла — for, но он используется как while и do-while!**

`break` - выход из цикла
`continue` - пропустить эту итерацию

```go
    // Обычный for
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }

    i := 0
    for i < 5 { // for как while
        fmt.Println(i)
        i++
    }

    for { // Бесконечный цикл!
        fmt.Println("Бесконечный цикл!")
    }

    nums := []int{1, 2, 3, 4, 5}
    for i, num := range nums { // Цикл по массиву (или срезу) — range
        fmt.Println("Индекс:", i, "Значение:", num)
    }

    for _, num := range nums { // Если индекс не нужен, можно игнорировать _
        fmt.Println(num)
    }

    Menu: // Создание lable над циклом, что позволяет влиять на внешний цикл из внутреннего
    for {
        for {
            // continue Menu
            // break Menu
        } 
    }
```

## Type Alias

`Type Alias` — это способ присвоить существующему типу новое имя. Объявляются через ключевое слово type с использованием знака равенства = Такой псевдоним не создает новый тип, а просто указывает, что MyInt — это другое имя для int. Компилятор воспринимает их как один и тот же тип

**Особенности:**

- Используются для удобства — позволяют давать более понятные имена существующим типам, например при работе с устаревшими API или для читаемости кода.
- Не создают новый тип — MyInt и int полностью взаимозаменяемы.
- Полезны при рефакторинге — можно временно ввести псевдоним для старого имени типа и постепенно переписать код.
- Отличие от "нового типа" — если убрать =, то создается новый тип, несовместимый с исходным

`ДОКУМЕНТАЦИЯ`: <https://go.dev/ref/spec#Type_declarations>

```go
    type (
        MyInt = int // Создание псевдонима для встроенного типа int
        CustomInt int  // Новый тип (отличие: нет знака '=') — несовместим с int
    )
```

## Fanctions

Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы

**В Go нет перегрузки методов!**

**Функция объявляется следующим образом:**

```go
    func имя_функции (список_параметров) (типы_возвращаемых_значений){
        выполняемые_операторы
        return результат1, результат2
    }
```

### Параметры функции

```plaintext
    При вызове функции передается копия значения переменной
```

```go
    // Параметры функции

    func add(x int, y int) {} // Пример стандартного объявления функции

    func add(x, y int, a, b, c float32){} // Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего параметра

    func add(numbers ...int) { // Пример функции с переменным количеством параметров. Аргумент с ... должен быть последним в функции
        // numbers будет являться обычным слайсом
    } 

    // Возвращение результата

    func add(x int, y int) int { // Если функция возвращает один параметр то его значение указывается после функции
        return x + y
    } 

    func add(x, y int) (z int) { // Возвращаемый результат может быть именован
        z = x + y
        return
    }

    func add(x int, y int) (int, error) { // Если необходимо вернуть несколько значений, то они перечисляются в скобках
        return x+y, nil
    } 
    // result, err := add(7, 3) - пример получения результата
    // var result, err = add(7, 3) - пример получения результата через var

    func add(x, y int, firstName, lastName string) (z int, fullName string) { // В даном случае можно было бы использовать именованные результаты
        z = x + y
        fullName = firstName + " " + lastName
        return
    }
    //  * Если используются именованные возвращаемые переменные, то они обязательно должны быть проименованны все
```

### Функции как значения и анонимные функции

В Go **функции являются первоклассными значениями** — их можно:

- присваивать переменным
- передавать в другие функции как аргументы
- возвращать из функций

`ДОКУМЕНТАЦИЯ`: <https://go.dev/ref/spec#Function_types>

```go
    // Функция как переменная
    var add func(int, int) int = func(a int, b int) int {
        return a + b
    }

    // Использование функции как аргумента, необходимо описать ее сигнатуру и возвращаемое значение
    func operate(a int, b int, f func(int, int) (int, error)) (int, error) {
        return f(a, b)
    }

    // Объявление типа функции
    type MathOp func(int, int) int

    func calc(a int, b int, op MathOp) int {
        return op(a, b)
    }

    // Анонимная функция сразу в вызове
    result := operate(10, 20, func(x, y int) int {
        return x * y
    })

    // Замыкание: функция захватывает внешнюю переменную. В Go компилятор создаёт для захваченных переменных отдельное замыкательное окружение (environment) и продлевает срок жизни этих переменных так, чтобы они были доступны даже после завершения внешней функции
    func makeCounter() func() int {
        count := 0
        return func() int {
            count++
            return count
        }
    }

    counter := makeCounter()
    fmt.Println(counter()) // 1
    fmt.Println(counter()) // 2
    fmt.Println(counter()) // 3
```

## Указатели

`Указатель` — это переменная, которая хранит адрес другой переменной в памяти. Они используются для передачи данных по ссылке, экономии памяти и изменения значений в функциях.

**Особенности:**

- Оператор & — получает адрес переменной.
- Оператор * — разыменовывает указатель (получает значение по адресу).
- Указатели не могут указывать в "никуда" — значение nil используется как нулевое.
- Go не поддерживает арифметику указателей (в отличие от C/C++).
- Автоматическая работа со ссылочными типами (срезы, карты, каналы) — они уже содержат внутренние указатели.
- Часто используются для изменения состояния в функциях.

```go
    var p *int // объявляем указатель на int
    p = &a // & — получаем адрес переменной a
    *p = 20 // изменяем значение по адресу

    func increment(x *int) { // Передача по указателю в функцию
        *x = *x + 1
    }
```

## defer

`defer` — это ключевое слово в Go, которое откладывает выполнение указанной функции до момента выхода из текущей функции (независимо от того, произошёл ли выход нормально или из-за паники).

Чаще всего используется для освобождения ресурсов, закрытия файлов и соединений, разблокировки мьютексов и других операций «уборки».

`ДОКУМЕНТАЦИЯ:` <https://go.dev/ref/spec#Defer_statements>

**Особенности:**

- **Выполняется в конце функции** — все отложенные вызовы срабатывают перед возвратом из функции.
- **LIFO-очередь** — вызовы выполняются в обратном порядке (последний defer — первый выполнится).
- Аргументы вычисляются сразу — даже если функция выполнится позже, её аргументы вычисляются в момент объявления defer.
- Работает даже при панике — полезно для корректной очистки ресурсов.
- Не откладывает объявление переменной — отложенный вызов — это полноценный вызов функции, но только выполненный позже.

```go
    x := 10
    defer fmt.Println("Значение x:", x) // x будет 10
    x = 20

    file, err := os.Create("data.txt")
    defer file.Close() // Закрытие файла при выходе из функции

    defer fmt.Println("Освобождение ресурсов") // Даже при панике отложенные вызовы будут выполнены перед завершением программы.
    panic("Что-то пошло не так")
```

## Перечисления (enum)

В Go нет enum в привычном смысле, как в Java. Вместо этого используется комбинация: именованных констант (const) + генератора значений iota

`iota` — это специальный идентификатор в Go, который используется внутри блока констант (const). Тип у него появляется только в момент, когда ты используешь iota в выражении или присваиваешь его какой-либо переменной/константе.

Go позволяет неявно приводить неименованные числовые константы (untyped int) к любому подходящему числовому типу (int8, int16, int32, int64, uint, uint8 и т.д.), если значение помещается в диапазон.

```go
    // Без указания типа — значения iota будут "untyped int"
    const (
        A = iota // 0
        B        // 1
        C        // 2
    )

    // С явным типом
    type Status int32
    const (
        Pending Status = iota // Pending: int32 = 0
        Approved              // Approved: int32 = 1
        Rejected              // Rejected: int32 = 2
    )

    // Битовые флаги
    type Flags uint8
    const (
        // Можно использовать в любых арифметических и побитовых выражениях
        Read Flags = 1 << iota // 00000001
        Write                  // 00000010
        Execute                // 00000100
    )
```

## Generics

`Generics` — это механизм обобщённого программирования, появившийся в Go 1.18. Он позволяет писать функции и типы, которые работают с разными типами данных, не дублируя код.

`ДОКУМЕНТАЦИЯ:` <https://go.dev/doc/tutorial/generics>

**Особенности:**

- Type constraint (ограничения типов) — определяют, с какими типами можно использовать функцию/тип.
- Monomorphization — компилятор создаёт конкретные версии функций под каждый используемый тип (как в C++ templates).
- Нельзя использовать generic в runtime reflection (например, reflect.TypeOf не даст параметризированный тип).

```go
    func PrintAll[T any](xs []T) {} // any — предобъявленный идентификатор, эквивалент старому interface{}.
    func IndexOf[T comparable](xs []T, target T) int // comparable полезен, если нужно сравнение или использование в map-ключах

    // ~ (approximation) — подлежащий тип
    // ~T означает «любой пользовательский тип, подлежащий тип которого T». Это позволяет принимать не только базовый тип, но и его type alias/новые именные типы с тем же underlying type

    type StringLike interface {
        ~string
    }

    // Часто ~ используют в «числовых» ограничениях:
    type SignedInts interface {
        ~int | ~int8 | ~int16 | ~int32 | ~int64 // Type set (объединение) ограничивает параметр типом из перечисления.
    }

    type UnsignedInts interface {
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
    }

    // Любой StringLike конкатенируется как строка.
    func Join2[T StringLike](a, b T) T {
        return a + b // работает, потому что у ~string есть оператор +
    }

    // Итог: {string, float64} ∩ {~int} = ∅
    type I1 interface {
        string | float64 // элемент №1: {string, float64}
        ~int            // элемент №2: {все типы с подлежащим int, включая int}
    }
```

### Generic struct

`Generic struct` — это структура с параметрами типа, которые определяются при создании экземпляра.

```go
    // Generic-структура с двумя параметрами: пара значений
    type Pair[K comparable, V any] struct {
        Key   K
        Value V
    }

    func (p Pair[K, V]) String() string {
        return fmt.Sprintf("%v=%v", p.Key, p.Value)
    }

    p := Pair[string, int]{Key: "age", Value: 30} // Использование Pair
    fmt.Println(p.String()) // age=30 
```
