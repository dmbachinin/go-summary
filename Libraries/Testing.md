# Testing

- [Testing](#testing)
  - [Go testing](#go-testing)
    - [\*testing.T - юнит-тесты](#testingt---юнит-тесты)

## Go testing

`testing` — стандартный пакет Go для написания и запуска тестов, бенчмарков, примеров и fuzz‑тестов.

**Общие правила:**

1. Файлы называются по принципу `*_test.go`, например, max_test.go
2. Имена функций: `TestXxx`, `BenchmarkXxx`, `ExampleXxx`, `FuzzXxx`
3. В Go тесты «живут» рядом с кодом каждого пакета, что лучше отражает модульность пакетов. Каждый пакет имеет свою директорию с исходниками и тестами. Это упрощает локальный контекст и импортируемость.
4. Общие входные данные кладут в подпапку `testdata` внутри конкретного пакета
5. **Два стиля тестов:**
    - package mypkg — white-box => тесты находятся в том же пакете, что и код (package mypkg в *_test.go) и имеют доступ к неэкспортируемым символам (внутренностям)
    - package mypkg_test — black-box => тесты пишутся как внешний клиент (package mypkg_test) и импортируют пакет, видя только экспортируемый API

```plantext
    go.mod
    foo/
        foo.go                 // код пакета foo
        foo_test.go            // white-box тесты (package foo)
        foo_external_test.go   // black-box тесты (package foo_test)
        testdata/              // файлы фикстур именно для пакета foo
            input.json
            golden/expected.txt
```

`ДОКУМЕНТАЦИЯ по testing:` <https://pkg.go.dev/testing>
`ДОКУМЕНТАЦИЯ по покрытию:` <https://pkg.go.dev/cmd/cover>
`ДОКУМЕНТАЦИЯ по статанализу:` <https://pkg.go.dev/cmd/vet>

**Основные команды:**

```sh
    # Юнит‑тесты
    go test ./... # Рекурсивный запуск всех тестов
    go test -v # Подробный вывод в консоль
    go test -parallel=N # Ограничит одновременные тесты. При использовании t.Parallel()
    go test -run='^TestSum$' # Фильтрация по имени

    # Бенчмарки
    go test -bench=. # Все бенчи

    # Fuzz
    go test -fuzz=Fuzz -run=^$ # Запуск fuzz‑таргетов

    # Покрытие
    go test -cover # Краткая метрика покрытия тестами
    go test -coverprofile=cover.out ./... && go tool cover -func=cover.out
    go tool cover -html=cover.out # Интерактивный отчет

    # Гонки
    go test -race ./... # Детектор гонок

    # Статический анализ
    go vet ./... # Находить типичные ошибки (дополняет тесты)
```

### *testing.T - юнит-тесты

```go
    import "testing"

    // Ошибки и провалы (основной рабочий набор)
    t.Fatalf(format string, args ...any) // Немедленный провал с форматированным сообщением; тест завершается.
    t.Errorf(format string, args ...any) // Сообщение об ошибке и пометка провала; выполнение теста продолжается.
    t.Error(args ...any) // То же, что Errorf, но без форматирования; тест не останавливается.
    t.Fatal(args ...any) // То же, что Fatalf, но без форматирования; тест сразу останавливается.
    t.FailNow() // Пометить провал и немедленно завершить текущий тест (не исполнять дальше).
    t.Fail() // Пометить провал, но позволить тесту продолжить выполнение.
    failed := t.Failed() bool // Узнать, провалился ли тест к текущему моменту.

    // Логи и вспомогательные хелперы
    t.Logf(format string, args ...any) // Записать форматированный лог теста (видно при -v или при провале).
    t.Log(args ...any) // Записать лог без форматирования.
    t.Helper() // Пометить вызывающую функцию как «хелпер», чтобы не засорять трейсбек.
    name := t.Name() string // Полное имя теста (включая иерархию под-тестов).
    w := t.Output() io.Writer // Поток вывода теста как io.Writer (без авто-перевода строки).

    // Под-тесты и параллельность
    ok := t.Run(name string, func(t *testing.T)) // Запустить под-тест с собственным *T; удобно для табличных тестов.
    t.Parallel() // Разрешить параллельный запуск этого теста вместе с другими, также вызвавшими t.Parallel().

    // Окружение и ресурсы
    dir := t.TempDir() string // Создать уникальную временную директорию; удалится автоматически после теста.
    t.Cleanup(func()) // Зарегистрировать очистку ресурсов; вызовы выполняются в обратном порядке.
    t.Setenv(key, value string) // Временно изменить переменную окружения; откатится автоматически.
    t.Chdir(dir string) // Временно сменить рабочую директорию; откат через Cleanup (осторожно с параллельными тестами).

    // Таймауты и контекст
    deadline, ok := t.Deadline() // Получить крайний срок выполнения теста (если задан флагом -timeout).
    ctx := t.Context() // Контекст теста, который отменяется перед Cleanup; удобно для graceful shutdown фоновых задач.

    // Пропуски
    t.Skipf(format string, args ...any) // Пропустить тест с пояснением (форматируемая строка).
    t.Skip(args ...any) // Пропустить тест с простым сообщением.
    t.SkipNow() // Немедленно пометить тест как пропущенный.
    sk := t.Skipped() bool // Узнать, был ли тест пропущен.

    // Метаданные/атрибуты (для отчётности в CI)
    t.Attr(key, value string) // Добавить произвольную метку/атрибут к тесту (для репортинга).

```

**Пример:**

```go
    import (
        "testing"
    )
    func TestSum_TableDriven(t *testing.T) {
        // Таблица кейсов
        tests := []struct{
            name string
            a, b int
            want int
        }{
            {"small", 1, 2, 3},
            {"zero", 0, 0, 0},
            {"negatives", -3, -7, -10},
        }

        for _, tc := range tests {
            tc := tc // захват в замыкании
            t.Run(tc.name, func(t *testing.T) {
                t.Parallel() // под‑тесты могут выполняться параллельно
                got := sum(tc.a, tc.b)
                if got != tc.want {
                    t.Fatalf("sum(%d,%d) = %d; want %d", tc.a, tc.b, got, tc.want)
                }
            })
        }
    }
```
