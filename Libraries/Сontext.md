# Context

`context` — стандартный механизм управления временем жизни операций, отменой, дедлайнами и передачей ограниченных «по запросу» значений вдоль цепочки вызовов и между горутинами. Контекст передаётся явным первым параметром функций, что делает отмену и дедлайны прозрачными и предсказуемыми. Рекомендуемые правила (не хранить Context в структурах, не передавать nil, ставить ctx первым параметром) закреплены прямо в документации пакета.

`ДОКУМЕНТАЦИЯ:` <https://pkg.go.dev/context>

- [Context](#context)
  - [Зачем нужен](#зачем-нужен)
  - [Идиомы и best practices](#идиомы-и-best-practices)
  - [Интерфейс Context](#интерфейс-context)
  - [Создание context](#создание-context)
  - [Оборачивание контекстов: дедлайны, отмена и приоритеты](#оборачивание-контекстов-дедлайны-отмена-и-приоритеты)

## Зачем нужен

1. `Кооперативная отмена работы`: закрытие ctx.Done() сигнализирует, что нужно остановиться. Ошибку причины см. в ctx.Err() или context.Cause(ctx).

2. `Управление временем`: WithDeadline/WithTimeout ограничивают длительность операций; дедлайн наследуется вниз по дереву контекстов.

3. `Передача «request-scoped» значений` (например, request-id, аутентификация) через WithValue. Не используйте для параметров бизнес-логики.

## Идиомы и best practices

1. `context-aware API` — это соглашение и паттерн проектирования функций и методов в Go, при котором каждая потенциально долгая или блокирующая операция принимает в качестве первого аргумента объект context.Context. `ctx` — всегда первый параметр (func Do(ctx context.Context, ...)). Не хранить в структурах, не передавать nil.  

2. `Отменяйте контексты, которые создаёте`: **ctx, cancel := context.WithTimeout(...); defer cancel()**. Иначе — утечки горутин/таймеров.
3. `Ключи для WithValue`: определяйте как НЕэкспортируемые пустые типы (во избежание коллизий), не используйте базовые типы (string, int). Рекомендация из стандартной доки и стиля Go. **В 99% случаев можно обойтись без WithValue**
4. Функция, которая принимает `context.Context`, обязана его уважать: периодически проверять отмену/дедлайн и пробрасывать ctx дальше. Отменяет (закрывает) контекст только тот, кто его создал через WithCancel/WithTimeout/WithDeadline: именно он вызывает cancel(). Получатель ctx никогда не вызывает cancel() и тем более не закрывает ctx.Done() (это канал только для чтения)

## Интерфейс Context

```go
    type Context interface {
        Deadline() (deadline time.Time, ok bool)
        // Возвращает дедлайн (если установлен) и флаг ok. Если дедлайна нет — ok = false.

        Done() <-chan struct{}
        // Канал, который закрывается при отмене контекста или наступлении дедлайна.
        // Используется в select для прерывания операций.

        Err() error
        // Возвращает причину завершения контекста:
        // - nil, если контекст ещё жив
        // - context.Canceled, если был отменён вручную
        // - context.DeadlineExceeded, если сработал дедлайн/таймаут

        Value(key any) any
        // Возвращает значение по ключу из контекста, либо nil если нет такого ключа.
    }
```

## Создание context

```go
    ctx := context.Background() // Создаёт пустой корневой контекст. 
    // Обычно используется как основа для серверов, main-функций.

    ctx := context.TODO() // Заглушка: использовать, когда ещё не ясно какой контекст нужен. 
    // Рекомендуется заменить на Background или наследуемый.

    // Отмена вручную
    ctx, cancel := context.WithCancel(parent) // Возвращает новый контекст и функцию cancel(), которую необходимо вызвать для освобождения ресурсов. Используется для ручного контроля отмены.
    defer cancel() // Если не вызвать cancel(), то таймеры/горутины могут утечь.

    
    ctx, cancel := context.WithCancelCause(parent) // Отмена вручную с указанием причины (Go 1.20+)
    // cancel(err) — отменяет контекст с причиной err.
    // Причину можно потом получить через context.Cause(ctx).

    ctx, cancel := context.WithDeadline(parent, deadline time.Time)     // Дедлайн (момент времени)
    // Отменяется, когда наступает deadline или вызывается cancel().
    // В ctx.Deadline() можно узнать установленный дедлайн.

    ctx, cancel := context.WithDeadlineCause(parent, deadline, err)
    // То же самое, но при срабатывании дедлайна в качестве причины отмены будет установлена ошибка err.

    // Таймаут (относительное время)
    ctx, cancel := context.WithTimeout(parent, timeout time.Duration)
    // Удобная обёртка над WithDeadline: дедлайн = now + timeout.
    // Применяется для ограничения времени работы операций.

    ctx, cancel := context.WithTimeoutCause(parent, timeout, err)
    // То же самое, но при срабатывании таймаута укажет причину err.

    // Контекст со значением
    ctx := context.WithValue(parent, key, value)     // Возвращает новый контекст, в котором по key хранится value.
    // Важно: ключи должны быть уникальными, обычно используют приватный тип struct{}.
    // НЕ использовать для передачи бизнес-данных, только request-scoped метаданные.

    // Контекст без отмены (Go 1.21+)
    ctx := context.WithoutCancel(parent) // Создаёт копию контекста, которая не будет отменена при отмене родителя.
    // Полезно для задач, которые должны выполняться до конца (например, логирование, аудит).

    err := context.Cause(ctx) // Возвращает причину отмены (ошибку, переданную в cancel() или установленную системой).
    // Если отмена произошла без причины — вернёт стандартную ошибку (Canceled или DeadlineExceeded).

    stop := context.AfterFunc(ctx, func()) (stop func() bool) // Позволяет назначить функцию, которая будет вызвана сразу после отмены ctx.
    // Возвращает функцию stop(), которая отменяет выполнение callback, если он ещё не запущен.
    // stop() возвращает true, если функция была остановлена до запуска.
```

`Функция cancel` освобождает ресурсы контекста и сигнализирует об отмене всем его потомкам. Но есть важные нюансы:

- cancel() не «закрывает» сам context.Context (его интерфейс остаётся работать), а лишь:
  1. закрывает канал Done() (он становится навсегда закрытым),
  2. устанавливает ошибку в Err()/Cause(),
  3. запускает все AfterFunc-хуки, привязанные к этому контексту,
  4. освобождает внутренние таймеры (если был WithTimeout/WithDeadline).
- Вызывать cancel() нужно всегда для контекстов, которые вы создали (даже если они уже истекли/были отменены). Это предотвращает утечки:
  - таймеры (time.Timer) в WithTimeout/WithDeadline продолжают тикать без cancel(),
  - внутренние ссылки на родительский контекст остаются до вызова cancel().
- **cancel() — идемпотентная**: несколько вызовов не приводят к панике и не ломают логику.
- Кто вызывает cancel()?
  - Только создатель контекста. Функции, которые его принимают, не должны и не могут «закрыть» чужой контекст.

## Оборачивание контекстов: дедлайны, отмена и приоритеты

`Оборачивание (WithCancel/WithTimeout/WithDeadline/WithValue/WithoutCancel) создаёт производный контекст поверх родительского`. Производный контекст наследует свойства родителя (отмену, дедлайн, значения) и **может ужесточать ограничения**(делать дедлайн короче, добавлять собственную отмену/причину), но **не может ослаблять их**. Исключение — WithoutCancel, который «обрубает» связь по отмене и дедлайну, сохраняя значения.

**Best practice:**

- Создаёте контекст — всегда вызывайте cancel() (обычно defer cancel()). **Внутренние функции не отменяют принятый ctx, а лишь уважают его** (Done()/Err() или context-aware API).

```go
    // Правило минимального дедлайна: родитель короче ребёнка
    // Итог: контекст завершится примерно через 1s, несмотря на 3s у ребёнка
    func minDeadlineExample(parent context.Context) (time.Duration, error) {
        pctx, pcancel := context.WithTimeout(parent, 1*time.Second)
        defer pcancel()

        cctx, ccancel := context.WithTimeout(pctx, 3*time.Second)
        defer ccancel()

        start := time.Now()
        <-cctx.Done() // сработает из-за родителя
        return time.Since(start), cctx.Err() // ожидаемо: context.DeadlineExceeded
    }

    // Ужесточение ограничения ребёнком: ребёнок завершается быстрее родителя
    // Итог: ~500ms, даже если у родителя 2s
    func childShorterThanParent(parent context.Context) (time.Duration, error) {
        pctx, pcancel := context.WithTimeout(parent, 2*time.Second)
        defer pcancel()

        cctx, ccancel := context.WithTimeout(pctx, 500*time.Millisecond)
        defer ccancel()

        start := time.Now()
        <-cctx.Done() // сработает из-за таймаута ребёнка
        return time.Since(start), cctx.Err() // context.DeadlineExceeded
    }
```
